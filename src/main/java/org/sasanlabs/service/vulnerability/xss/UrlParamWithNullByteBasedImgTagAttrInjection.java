package org.sasanlabs.service.vulnerability.xss;

import static org.sasanlabs.vulnerability.utils.Constants.NULL_BYTE_CHARACTER;

import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import org.apache.commons.text.StringEscapeUtils;
import org.sasanlabs.internal.utility.LevelEnum;
import org.sasanlabs.internal.utility.annotations.ResponseType;
import org.sasanlabs.internal.utility.annotations.VulnerabilityLevel;
import org.sasanlabs.internal.utility.annotations.VulnerableServiceRestEndPoint;
import org.sasanlabs.service.bean.ResponseBean;
import org.sasanlabs.service.vulnerability.ICustomVulnerableEndPoint;
import org.sasanlabs.service.vulnerability.ParameterBean;
import org.sasanlabs.vulnerability.types.VulnerabilityType;
import org.sasanlabs.vulnerability.utils.Constants;

/**
 * This class exposes the restful services which are vulnerable to XSS and Null Byte Injection vulnerabilities. 
 * Both these vulnerabilities are present in Image Tag's src attribute i.e. {@code <img src=value />}
 * 
 * @author KSASAN preetkaran20@gmail.com
 */
@VulnerableServiceRestEndPoint(descriptionLabel = "XSS_NULL_BYTE_IMAGE_TAG_INJECTION", value = "XXSWithNullBytesImgTagAttribute", type = {
		VulnerabilityType.XSS, VulnerabilityType.NULL_BYTE })
public class UrlParamWithNullByteBasedImgTagAttrInjection implements ICustomVulnerableEndPoint {

	private ParameterBean parameterBean;

	private Set<String> allowedValues = new HashSet<>();

	public UrlParamWithNullByteBasedImgTagAttrInjection() {
		allowedValues.add("images/owasp.png");
		allowedValues.add("images/ZAP.png");
	}
	
	@Override
	public void setParameterBean(ParameterBean urlParamBean) {
		this.parameterBean = urlParamBean;
	}

	// Just adding User defined input(Untrusted Data) incase it contains Null Byte
	// into Src tag is not secure.
	// Can be broken by various ways
	@VulnerabilityLevel(value = LevelEnum.LEVEL_1, descriptionLabel = "XSS_NULL_BYTE_DIRECT_INPUT_SRC_ATTRIBUTE_IMG_TAG", htmlTemplate = "LEVEL_1/XSS", responseType = ResponseType.HTML_TAGS_ONLY)
	public ResponseBean<String> getVulnerablePayloadLevelUnsecure() {
		String vulnerablePayloadWithPlaceHolder = "<img src=%s 	width=\"400\" height=\"300\"/>";
		StringBuilder payload = new StringBuilder();
		for (Map.Entry<String, String> map : this.parameterBean.getQueryParamKeyValueMap().entrySet()) {
			if (map.getValue().equals(Constants.getEyeCatcher()) || map.getValue().contains(NULL_BYTE_CHARACTER) || allowedValues.contains(map.getValue())) {
				payload.append(String.format(vulnerablePayloadWithPlaceHolder, map.getValue()));
			}
		}
		return new ResponseBean<String>(payload.toString());
	}

	// Just adding User defined input(Untrusted Data) untill Null Byte incase it
	// contains Null Byte
	// into Src tag is not secure.
	// Can be broken by various ways
	@VulnerabilityLevel(value = LevelEnum.LEVEL_2, descriptionLabel = "XSS_PARSER_STOPS_AT_NULL_BYTE_ON_INPUT_AND_INSERTS_TILL_THAT_TO_SRC_ATTRIBUTE_IMG_TAG", htmlTemplate = "LEVEL_1/XSS", responseType = ResponseType.HTML_TAGS_ONLY)
	public ResponseBean<String> getVulnerablePayloadLevelLow() {
		String vulnerablePayloadWithPlaceHolder = "<img src=%s width=\"400\" height=\"300\"/>";
		StringBuilder payload = new StringBuilder();
		for (Map.Entry<String, String> map : this.parameterBean.getQueryParamKeyValueMap().entrySet()) {
			String parameterValue = map.getValue();
			if (parameterValue.equals(Constants.getEyeCatcher()) || parameterValue.contains(NULL_BYTE_CHARACTER)) {
				String parsedParameterValue;
				if (parameterValue.equals(Constants.getEyeCatcher())) {
					parsedParameterValue = parameterValue;
				} else {
					parsedParameterValue = 
							parameterValue.substring(parameterValue.indexOf(NULL_BYTE_CHARACTER));
				}
				payload.append(String.format(vulnerablePayloadWithPlaceHolder,parsedParameterValue));
			}
		}
		return new ResponseBean<String>(payload.toString());
	}

	// Adding Untrusted Data into Src tag between quotes is beneficial but not
	// without escaping the input
	@VulnerabilityLevel(value = LevelEnum.LEVEL_3, descriptionLabel = "XSS_QUOTES_NULL_BYTES_ON_INPUT_SRC_ATTRIBUTE_IMG_TAG", htmlTemplate = "LEVEL_1/XSS", responseType = ResponseType.HTML_TAGS_ONLY)
	public ResponseBean<String> getVulnerablePayloadLevelMedium() {
		String vulnerablePayloadWithPlaceHolder = "<img src=\"%s\" width=\"400\" height=\"300\"/>";
		StringBuilder payload = new StringBuilder();
		for (Map.Entry<String, String> map : this.parameterBean.getQueryParamKeyValueMap().entrySet()) {
			if (map.getValue().equals(Constants.getEyeCatcher()) || map.getValue().contains(NULL_BYTE_CHARACTER)) {
				payload.append(String.format(vulnerablePayloadWithPlaceHolder, map.getValue()));
			}
		}
		return new ResponseBean<String>(payload.toString());
	}

	// Good way for HTML escapes so hacker cannot close the tags but can use event
	// handlers like onerror etc. eg:- '%00'onerror='alert(1);'
	@VulnerabilityLevel(value = LevelEnum.LEVEL_4, descriptionLabel = "XSS_NULL_BYTE_HTML_ESCAPE_ON_DIRECT_INPUT_SRC_ATTRIBUTE_IMG_TAG", htmlTemplate = "LEVEL_1/XSS", responseType = ResponseType.HTML_TAGS_ONLY)
	public ResponseBean<String> getVulnerablePayloadLevelHigh() {
		String vulnerablePayloadWithPlaceHolder = "<img src=%s width=\"400\" height=\"300\"/>";
		StringBuilder payload = new StringBuilder();
		for (Map.Entry<String, String> map : this.parameterBean.getQueryParamKeyValueMap().entrySet()) {
			if (map.getValue().equals(Constants.getEyeCatcher()) || map.getValue().contains(NULL_BYTE_CHARACTER)) {
				payload.append(
						String.format(vulnerablePayloadWithPlaceHolder, StringEscapeUtils.escapeHtml4(map.getValue())));
			}
		}
		return new ResponseBean<String>(payload.toString());
	}


	// Good way and can protect against attacks but it is better to have check on
	// the input values provided if possible.
	@VulnerabilityLevel(value = LevelEnum.LEVEL_5, descriptionLabel = "XSS_NULL_BYTE_QUOTES_AND_WITH_HTML_ESCAPE_ON_INPUT_SRC_ATTRIBUTE_IMG_TAG", htmlTemplate = "LEVEL_1/XSS", responseType = ResponseType.HTML_TAGS_ONLY)
	public ResponseBean<String> getVulnerablePayloadLevelVeryHigh() {
		String vulnerablePayloadWithPlaceHolder = "<img src=\"%s\" width=\"400\" height=\"300\"/>";
		StringBuilder payload = new StringBuilder();
		for (Map.Entry<String, String> map : this.parameterBean.getQueryParamKeyValueMap().entrySet()) {
			if (map.getValue().equals(Constants.getEyeCatcher()) || map.getValue().contains(NULL_BYTE_CHARACTER)) {
				payload.append(
						String.format(vulnerablePayloadWithPlaceHolder, StringEscapeUtils.escapeHtml4(map.getValue())));
			}
		}
		return new ResponseBean<String>(payload.toString());
	}

	// Good way and can protect against attacks but it is better to have check on
	// the input values provided if possible.
	@VulnerabilityLevel(value = LevelEnum.SECURE, descriptionLabel = "XSS_QUOTES_AND_WITH_HTML_ESCAPE_PLUS_FILTERING_ON_INPUT_SRC_ATTRIBUTE_IMG_TAG", htmlTemplate = "LEVEL_1/XSS", responseType = ResponseType.HTML_TAGS_ONLY)
	public ResponseBean<String> getVulnerablePayloadLevelSecure() {
		String vulnerablePayloadWithPlaceHolder = "<img src=\"%s\" 	width=\"400\" height=\"300\"/>";
		StringBuilder payload = new StringBuilder();
		for (Map.Entry<String, String> map : this.parameterBean.getQueryParamKeyValueMap().entrySet()) {
			if (map.getValue().equals(Constants.getEyeCatcher()) || allowedValues.contains(map.getValue())) {
				payload.append(
						String.format(vulnerablePayloadWithPlaceHolder, StringEscapeUtils.escapeHtml4(map.getValue())));
			}
		}
		return new ResponseBean<String>(payload.toString());
	}

}
