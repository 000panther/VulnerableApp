package org.sasanlabs.service.vulnerability.sqlInjection;

import com.fasterxml.jackson.core.JsonProcessingException;
import java.util.function.Function;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.sasanlabs.internal.utility.JSONSerializationUtils;
import org.sasanlabs.internal.utility.LevelEnum;
import org.sasanlabs.internal.utility.annotations.AttackVector;
import org.sasanlabs.internal.utility.annotations.VulnerabilityLevel;
import org.sasanlabs.internal.utility.annotations.VulnerableServiceRestEndPoint;
import org.sasanlabs.service.bean.ResponseBean;
import org.sasanlabs.service.vulnerability.ICustomVulnerableEndPoint;
import org.sasanlabs.service.vulnerability.ParameterBean;
import org.sasanlabs.vulnerability.types.VulnerabilityType;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.jdbc.core.JdbcTemplate;

/**
 * Error Based SQLInjection is the easiest way for extracting data and a very dangerous way which
 * can lead to serious impacts and can compromise the entire system.
 *
 * @author preetkaran20@gmail.com KSASAN
 */
@VulnerableServiceRestEndPoint(
        descriptionLabel = "SQL_INJECTION_VULNERABILITY",
        type = {VulnerabilityType.SQL_INJECTION},
        value = "ErrorBasedSQLInjectionVulnerability")
public class ErrorBasedSQLInjectionVulnerability implements ICustomVulnerableEndPoint {

    @Qualifier("applicationJdbcTemplate")
    @Autowired
    private JdbcTemplate applicationJdbcTemplate;

    private static final transient Logger LOGGER =
            LogManager.getLogger(ErrorBasedSQLInjectionVulnerability.class);

    private static final Function<Exception, String> GENERIC_EXCEPTION_RESPONSE_FUNCTION =
            (ex) -> "{ \"isCarPresent\": false, \"moreInfo\": " + ex.getMessage() + "}";
    static final String CAR_IS_NOT_PRESENT_RESPONSE = "{ \"isCarPresent\": false}";
    static final Function<String, String> CAR_IS_PRESENT_RESPONSE =
            (carInformation) ->
                    "{ \"isCarPresent\": true, \"carInformation\":" + carInformation + "}";

    @AttackVector(
            vulnerabilityExposed = VulnerabilityType.SQL_INJECTION,
            description = "ERROR_SQL_INJECTION_URL_PARAM_APPENDED_DIRECTLY_TO_QUERY")
    @VulnerabilityLevel(
            value = LevelEnum.LEVEL_1,
            descriptionLabel = "URL_CONTAINING_CAR_ID_PARAMETER",
            htmlTemplate = "LEVEL_1/SQLInjection_Level1")
    public ResponseBean<String> doesCarInformationExistsLevel1(ParameterBean parameterBean) {
        String id = parameterBean.getQueryParamKeyValueMap().get("id");
        final ResponseBean<String> responseBean =
                new ResponseBean<String>(CAR_IS_NOT_PRESENT_RESPONSE);
        try {
            applicationJdbcTemplate.query(
                    "select * from cars where id=" + id,
                    (rs) -> {
                        CarInformation carInformation = new CarInformation();
                        carInformation.setId(rs.getInt(1));
                        carInformation.setName(rs.getString(2));
                        carInformation.setImagePath(rs.getString(3));
                        try {
                            responseBean.setBody(
                                    CAR_IS_PRESENT_RESPONSE.apply(
                                            JSONSerializationUtils.serialize(carInformation)));
                        } catch (JsonProcessingException e) {
                            LOGGER.error("Following error occurred", e);
                        }
                    });
        } catch (Exception ex) {
            responseBean.setBody(GENERIC_EXCEPTION_RESPONSE_FUNCTION.apply(ex));
        }
        return responseBean;
    }

    @AttackVector(
            vulnerabilityExposed = VulnerabilityType.SQL_INJECTION,
            description = "ERROR_SQL_INJECTION_URL_PARAM_WRAPPED_WITH_SINGLE_QUOTE_APPENDED_TO_QUERY")
    @VulnerabilityLevel(
            value = LevelEnum.LEVEL_2,
            descriptionLabel = "URL_CONTAINING_CAR_ID_PARAMETER",
            htmlTemplate = "LEVEL_1/SQLInjection_Level1")
    public ResponseBean<String> doesCarInformationExistsLevel2(ParameterBean parameterBean) {
        String id = parameterBean.getQueryParamKeyValueMap().get("id");
        final ResponseBean<String> responseBean =
                new ResponseBean<String>(CAR_IS_NOT_PRESENT_RESPONSE);
        try {
            applicationJdbcTemplate.query(
                    "select * from cars where id='" + id + "'",
                    (rs) -> {
                        CarInformation carInformation = new CarInformation();
                        carInformation.setId(rs.getInt(1));
                        carInformation.setName(rs.getString(2));
                        carInformation.setImagePath(rs.getString(3));
                        try {
                            responseBean.setBody(
                                    CAR_IS_PRESENT_RESPONSE.apply(
                                            JSONSerializationUtils.serialize(carInformation)));
                        } catch (JsonProcessingException e) {
                            LOGGER.error("Following error occurred", e);
                        }
                    });
        } catch (Exception ex) {
            responseBean.setBody(GENERIC_EXCEPTION_RESPONSE_FUNCTION.apply(ex));
        }
        return responseBean;
    }

    // https://stackoverflow.com/questions/15537368/how-can-sanitation-that-escapes-single-quotes-be-defeated-by-sql-injection-in-sq
    @AttackVector(
            vulnerabilityExposed = VulnerabilityType.SQL_INJECTION,
            description = "ERROR_SQL_INJECTION_URL_PARAM_REMOVES_SINGLE_QUOTE_WRAPPED_WITH_SINGLE_QUOTE_APPENDED_TO_QUERY")
    @VulnerabilityLevel(
            value = LevelEnum.LEVEL_3,
            descriptionLabel = "URL_CONTAINING_CAR_ID_PARAMETER",
            htmlTemplate = "LEVEL_1/SQLInjection_Level1")
    public ResponseBean<String> doesCarInformationExistsLevel3(ParameterBean parameterBean) {
        String id = parameterBean.getQueryParamKeyValueMap().get("id");
        id = id.replaceAll("'", "");
        final ResponseBean<String> responseBean =
                new ResponseBean<String>(CAR_IS_NOT_PRESENT_RESPONSE);
        try {
            applicationJdbcTemplate.query(
                    "select * from cars where id='" + id + "'",
                    (rs) -> {
                        CarInformation carInformation = new CarInformation();

                        carInformation.setId(rs.getInt(1));
                        carInformation.setName(rs.getString(2));
                        carInformation.setImagePath(rs.getString(3));
                        try {
                            responseBean.setBody(
                                    CAR_IS_PRESENT_RESPONSE.apply(
                                            JSONSerializationUtils.serialize(carInformation)));
                        } catch (JsonProcessingException e) {
                            LOGGER.error("Following error occurred", e);
                        }
                    });

        } catch (Exception ex) {
            responseBean.setBody(GENERIC_EXCEPTION_RESPONSE_FUNCTION.apply(ex));
        }
        return responseBean;
    }

    // Assumption that only creating PreparedStatement object can save is wrong. You
    // need to use the parameterized query properly.
    @AttackVector(
            vulnerabilityExposed = VulnerabilityType.SQL_INJECTION,
            description = "ERROR_SQL_INJECTION_URL_PARAM_APPENDED_TO_PARAMETERIZED_QUERY")
    @VulnerabilityLevel(
            value = LevelEnum.LEVEL_4,
            descriptionLabel = "URL_CONTAINING_CAR_ID_PARAMETER",
            htmlTemplate = "LEVEL_1/SQLInjection_Level1")
    public ResponseBean<String> doesCarInformationExistsLevel4(ParameterBean parameterBean) {
        final String id = parameterBean.getQueryParamKeyValueMap().get("id").replaceAll("'", "");
        final ResponseBean<String> responseBean =
                new ResponseBean<String>(CAR_IS_NOT_PRESENT_RESPONSE);
        try {
            applicationJdbcTemplate.query(
                    (conn) -> conn.prepareStatement("select * from cars where id='" + id + "'"),
                    (ps) -> {},
                    (rs) -> {
                        while (rs.next()) {
                            CarInformation carInformation = new CarInformation();

                            carInformation.setId(rs.getInt(1));
                            carInformation.setName(rs.getString(2));
                            carInformation.setImagePath(rs.getString(3));
                            try {
                                responseBean.setBody(
                                        CAR_IS_PRESENT_RESPONSE.apply(
                                                JSONSerializationUtils.serialize(carInformation)));
                            } catch (JsonProcessingException e) {
                                LOGGER.error("Following error occurred", e);
                            }
                        }
                        return null;
                    });
        } catch (Exception ex) {
            responseBean.setBody(GENERIC_EXCEPTION_RESPONSE_FUNCTION.apply(ex));
        }
        return responseBean;
    }

    @VulnerabilityLevel(
            value = LevelEnum.LEVEL_5,
            descriptionLabel = "URL_CONTAINING_CAR_ID_PARAMETER",
            htmlTemplate = "LEVEL_1/SQLInjection_Level1")
    public ResponseBean<String> doesCarInformationExistsLevel5(ParameterBean parameterBean) {
        final String id = parameterBean.getQueryParamKeyValueMap().get("id");
        final ResponseBean<String> responseBean =
                new ResponseBean<String>(CAR_IS_NOT_PRESENT_RESPONSE);
        try {
            applicationJdbcTemplate.query(
                    (conn) -> conn.prepareStatement("select * from cars where id=?"),
                    (prepareStatement) -> {
                        prepareStatement.setString(1, id);
                    },
                    (rs) -> {
                        CarInformation carInformation = new CarInformation();
                        while (rs.next()) {
                            carInformation.setId(rs.getInt(1));
                            carInformation.setName(rs.getString(2));
                            carInformation.setImagePath(rs.getString(3));
                        }
                        try {
                            responseBean.setBody(
                                    CAR_IS_PRESENT_RESPONSE.apply(
                                            JSONSerializationUtils.serialize(carInformation)));
                        } catch (JsonProcessingException e) {
                            LOGGER.error("Following error occurred", e);
                        }
                        return null;
                    });
        } catch (Exception ex) {
            responseBean.setBody(GENERIC_EXCEPTION_RESPONSE_FUNCTION.apply(ex));
        }
        return responseBean;
    }
}
