package org.sasanlabs.service.vulnerability.sqlInjection;

import java.util.function.Function;
import org.sasanlabs.internal.utility.LevelEnum;
import org.sasanlabs.internal.utility.annotations.AttackVector;
import org.sasanlabs.internal.utility.annotations.VulnerabilityLevel;
import org.sasanlabs.internal.utility.annotations.VulnerableServiceRestEndPoint;
import org.sasanlabs.service.bean.ResponseBean;
import org.sasanlabs.service.vulnerability.ICustomVulnerableEndPoint;
import org.sasanlabs.service.vulnerability.ParameterBean;
import org.sasanlabs.vulnerability.types.VulnerabilityType;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.PreparedStatementSetter;

/**
 * Error Based SQLInjection is the easiest way for extracting data and a very dangerous way which
 * can lead to serious impacts and can compromise the entire system.
 *
 * @author preetkaran20@gmail.com KSASAN
 */
@VulnerableServiceRestEndPoint(
        descriptionLabel = "SQL_INJECTION_VULNERABILITY",
        type = {VulnerabilityType.SQL_INJECTION},
        value = "ErrorBasedSQLInjectionVulnerability")
public class ErrorBasedSQLInjectionVulnerability implements ICustomVulnerableEndPoint {

    @Autowired private JdbcTemplate jdbcTemplate;

    private static final Function<Exception, String> GENERIC_EXCEPTION_RESPONSE_FUNCTION =
            (ex) -> "{ \"isCarPresent\": false, \"moreInfo\": " + ex.getMessage() + "}";
    static final String CAR_IS_NOT_PRESENT_RESPONSE = "{ \"isCarPresent\": false}";
    static final String CAR_IS_PRESENT_RESPONSE = "{ \"isCarPresent\": true}";

    @AttackVector(
            vulnerabilityExposed = VulnerabilityType.SQL_INJECTION,
            description = "JWT_URL_EXPOSING_SECURE_INFORMATION")
    @VulnerabilityLevel(
            value = LevelEnum.LEVEL_1,
            descriptionLabel = "URL_CONTAINING_JWT_TOKEN",
            htmlTemplate = "LEVEL_1/SQLInjection_Level1")
    public ResponseBean<String> doesCarInformationExistsLevel1(ParameterBean parameterBean) {
        String id = parameterBean.getQueryParamKeyValueMap().get("id");
        final ResponseBean<String> responseBean = new ResponseBean<String>(CAR_IS_NOT_PRESENT_RESPONSE);
        try {
            jdbcTemplate.query(
                    "select count(*) from cars where id=" + id,
                    (rs) -> {
                        if (rs.getInt(1) > 0) {
                            responseBean.setBody(CAR_IS_PRESENT_RESPONSE);
                        }
                    });
        } catch (Exception ex) {
            responseBean.setBody(GENERIC_EXCEPTION_RESPONSE_FUNCTION.apply(ex));
        }
        return responseBean;
    }

    @AttackVector(
            vulnerabilityExposed = VulnerabilityType.SQL_INJECTION,
            description = "JWT_URL_EXPOSING_SECURE_INFORMATION")
    @VulnerabilityLevel(
            value = LevelEnum.LEVEL_2,
            descriptionLabel = "URL_CONTAINING_JWT_TOKEN",
            htmlTemplate = "LEVEL_1/SQLInjection_Level1")
    public ResponseBean<String> doesCarInformationExistsLevel2(ParameterBean parameterBean) {
        String id = parameterBean.getQueryParamKeyValueMap().get("id");
        final ResponseBean<String> responseBean =
                new ResponseBean<String>(CAR_IS_NOT_PRESENT_RESPONSE);
        try {
            jdbcTemplate.query(
                    "select count(*) from cars where id='" + id + "'",
                    (rs) -> {
                        if (rs.getInt(1) > 0) {
                            responseBean.setBody(CAR_IS_PRESENT_RESPONSE);
                        }
                    });
        } catch (Exception ex) {
            responseBean.setBody(GENERIC_EXCEPTION_RESPONSE_FUNCTION.apply(ex));
        }
        return responseBean;
    }

    // https://stackoverflow.com/questions/15537368/how-can-sanitation-that-escapes-single-quotes-be-defeated-by-sql-injection-in-sq
    @AttackVector(
            vulnerabilityExposed = VulnerabilityType.SQL_INJECTION,
            description = "JWT_URL_EXPOSING_SECURE_INFORMATION")
    @VulnerabilityLevel(
            value = LevelEnum.LEVEL_3,
            descriptionLabel = "URL_CONTAINING_JWT_TOKEN",
            htmlTemplate = "LEVEL_1/SQLInjection_Level1")
    public ResponseBean<String> doesCarInformationExistsLevel3(ParameterBean parameterBean) {
        String id = parameterBean.getQueryParamKeyValueMap().get("id");
        id = id.replaceAll("'", "");
        final ResponseBean<String> responseBean =
                new ResponseBean<String>(CAR_IS_NOT_PRESENT_RESPONSE);
        try {
            jdbcTemplate.query(
                    "select count(*) from cars where id='" + id + "'",
                    (rs) -> {
                        if (rs.getInt(1) > 0) {
                            responseBean.setBody(CAR_IS_PRESENT_RESPONSE);
                        }
                    });
        } catch (Exception ex) {
            responseBean.setBody(GENERIC_EXCEPTION_RESPONSE_FUNCTION.apply(ex));
        }
        return responseBean;
    }

    // Assumption that only creating PreparedStatement object can save is wrong. You
    // need to use the parameterized query properly.
    @AttackVector(
            vulnerabilityExposed = VulnerabilityType.SQL_INJECTION,
            description = "JWT_URL_EXPOSING_SECURE_INFORMATION")
    @VulnerabilityLevel(
            value = LevelEnum.LEVEL_4,
            descriptionLabel = "URL_CONTAINING_JWT_TOKEN",
            htmlTemplate = "LEVEL_1/SQLInjection_Level1")
    public ResponseBean<String> doesCarInformationExistsLevel4(ParameterBean parameterBean) {
        final String id = parameterBean.getQueryParamKeyValueMap().get("id").replaceAll("'", "");
        final ResponseBean<String> responseBean =
                new ResponseBean<String>(CAR_IS_NOT_PRESENT_RESPONSE);
        try {
            jdbcTemplate.query(
                    (conn) ->
                            conn.prepareStatement(
                                    "select count(*) from cars where id='" + id + "'"),
                    (PreparedStatementSetter) null,
                    (rs) -> {
                        if (rs.getInt(1) > 0) {
                            responseBean.setBody(CAR_IS_PRESENT_RESPONSE);
                        }
                        return null;
                    });
        } catch (Exception ex) {
            responseBean.setBody(GENERIC_EXCEPTION_RESPONSE_FUNCTION.apply(ex));
        }
        return responseBean;
    }

    // Valid way to circumvent
    @AttackVector(
            vulnerabilityExposed = VulnerabilityType.SQL_INJECTION,
            description = "JWT_URL_EXPOSING_SECURE_INFORMATION")
    @VulnerabilityLevel(
            value = LevelEnum.LEVEL_5,
            descriptionLabel = "URL_CONTAINING_JWT_TOKEN",
            htmlTemplate = "LEVEL_1/SQLInjection_Level1")
    public ResponseBean<String> doesCarInformationExistsLevel5(ParameterBean parameterBean) {
        final String id = parameterBean.getQueryParamKeyValueMap().get("id").replaceAll("'", "");
        final ResponseBean<String> responseBean =
                new ResponseBean<String>(CAR_IS_NOT_PRESENT_RESPONSE);
        try {
            jdbcTemplate.query(
                    (conn) -> conn.prepareStatement("select count(*) from cars where id=?"),
                    (prepareStatement) -> {
                        prepareStatement.setString(0, id);
                    },
                    (rs) -> {
                        if (rs.getInt(1) > 0) {
                            responseBean.setBody(CAR_IS_PRESENT_RESPONSE);
                        }
                        return null;
                    });
        } catch (Exception ex) {
            responseBean.setBody(CAR_IS_NOT_PRESENT_RESPONSE);
        }
        return responseBean;
    }
}
