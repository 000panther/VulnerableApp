package org.sasanlabs.service.vulnerability.sqlInjection;

import org.sasanlabs.internal.utility.LevelEnum;
import org.sasanlabs.internal.utility.annotations.AttackVector;
import org.sasanlabs.internal.utility.annotations.VulnerabilityLevel;
import org.sasanlabs.internal.utility.annotations.VulnerableServiceRestEndPoint;
import org.sasanlabs.service.bean.ResponseBean;
import org.sasanlabs.service.vulnerability.ICustomVulnerableEndPoint;
import org.sasanlabs.service.vulnerability.ParameterBean;
import org.sasanlabs.vulnerability.types.VulnerabilityType;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;

/** @author preetkaran20@gmail.com KSASAN */
@VulnerableServiceRestEndPoint(
        descriptionLabel = "SQL_INJECTION_VULNERABILITY",
        type = {VulnerabilityType.SQL_INJECTION},
        value = "BlindSQLInjectionVulnerability")
public class BlindSQLInjectionVulnerability implements ICustomVulnerableEndPoint {
    @Autowired private JdbcTemplate jdbcTemplate;

    // Blind Injection which just checks if the car id is present in database or not
    // Example of Boolean based SQL Injection
    @AttackVector(
            vulnerabilityExposed = VulnerabilityType.SQL_INJECTION,
            description = "JWT_URL_EXPOSING_SECURE_INFORMATION")
    @VulnerabilityLevel(
            value = LevelEnum.LEVEL_1,
            descriptionLabel = "URL_CONTAINING_JWT_TOKEN",
            htmlTemplate = "LEVEL_1/SQLInjection_Level1")
    public ResponseBean<String> getCarInformationLevel1(ParameterBean parameterBean) {
        String id = parameterBean.getQueryParamKeyValueMap().get("id");
        boolean isCarInfoAvailable =
                jdbcTemplate.queryForMap("select * from cars where id=" + id).size() > 0;
        return new ResponseBean<String>(String.valueOf(isCarInfoAvailable));
    }
}
