package org.sasanlabs.service.vulnerability.sqlInjection;

import org.sasanlabs.internal.utility.LevelEnum;
import org.sasanlabs.internal.utility.annotations.AttackVector;
import org.sasanlabs.internal.utility.annotations.VulnerabilityLevel;
import org.sasanlabs.internal.utility.annotations.VulnerableServiceRestEndPoint;
import org.sasanlabs.service.bean.ResponseBean;
import org.sasanlabs.service.vulnerability.ICustomVulnerableEndPoint;
import org.sasanlabs.service.vulnerability.ParameterBean;
import org.sasanlabs.vulnerability.types.VulnerabilitySubType;
import org.sasanlabs.vulnerability.types.VulnerabilityType;
import org.sasanlabs.vulnerability.utils.Constants;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.jdbc.core.JdbcTemplate;

/**
 * This is the most difficult and slowest attack which is done only if Error Based and Union Based
 * SQLInjections are not possible. In this attack response from the API is just {@code true} or
 * {@code false} and to get the data from the API time based/condition based attacks are done like
 * Wait for 10 seconds if 5 users are there in the data based and this way if query starts following
 * those conditions then this attack is possible.
 *
 * @author preetkaran20@gmail.com KSASAN
 */
@VulnerableServiceRestEndPoint(
        descriptionLabel = "SQL_INJECTION_VULNERABILITY",
        type = {VulnerabilityType.SQL_INJECTION},
        value = "BlindSQLInjectionVulnerability")
public class BlindSQLInjectionVulnerability implements ICustomVulnerableEndPoint {

    @Qualifier("applicationJdbcTemplate")
    @Autowired
    private JdbcTemplate applicationJdbcTemplate;

    static final String CAR_IS_PRESENT_RESPONSE = "{ \"isCarPresent\": true}";

    @AttackVector(
            vulnerabilityExposed = VulnerabilitySubType.BLIND_SQL_INJECTION,
            description = "BLIND_SQL_INJECTION_URL_PARAM_APPENDED_DIRECTLY_TO_QUERY")
    @VulnerabilityLevel(
            value = LevelEnum.LEVEL_1,
            descriptionLabel = "URL_CONTAINING_CAR_ID_PARAMETER",
            htmlTemplate = "LEVEL_1/SQLInjection_Level1",
            parameterName = Constants.ID,
            sampleValues = "1")
    public ResponseBean<String> getCarInformationLevel1(ParameterBean parameterBean) {
        String id = parameterBean.getQueryParamKeyValueMap().get(Constants.ID);
        ResponseBean<String> responseBean =
                new ResponseBean<>(ErrorBasedSQLInjectionVulnerability.CAR_IS_NOT_PRESENT_RESPONSE);

        applicationJdbcTemplate.query(
                "select * from cars where id=" + id,
                (rs) -> {
                    responseBean.setBody(CAR_IS_PRESENT_RESPONSE);
                });
        return responseBean;
    }

    @AttackVector(
            vulnerabilityExposed = VulnerabilitySubType.BLIND_SQL_INJECTION,
            description =
                    "BLIND_SQL_INJECTION_URL_PARAM_WRAPPED_WITH_SINGLE_QUOTE_APPENDED_TO_QUERY")
    @VulnerabilityLevel(
            value = LevelEnum.LEVEL_2,
            descriptionLabel = "URL_CONTAINING_CAR_ID_PARAMETER",
            htmlTemplate = "LEVEL_1/SQLInjection_Level1",
            parameterName = Constants.ID,
            sampleValues = "1")
    public ResponseBean<String> getCarInformationLevel2(ParameterBean parameterBean) {
        String id = parameterBean.getQueryParamKeyValueMap().get(Constants.ID);
        ResponseBean<String> responseBean =
                new ResponseBean<>(ErrorBasedSQLInjectionVulnerability.CAR_IS_NOT_PRESENT_RESPONSE);

        applicationJdbcTemplate.query(
                "select * from cars where id='" + id + "'",
                (rs) -> {
                    responseBean.setBody(CAR_IS_PRESENT_RESPONSE);
                });
        return responseBean;
    }

    @VulnerabilityLevel(
            value = LevelEnum.LEVEL_3,
            descriptionLabel = "URL_CONTAINING_CAR_ID_PARAMETER",
            htmlTemplate = "LEVEL_1/SQLInjection_Level1",
            parameterName = Constants.ID,
            sampleValues = "1")
    public ResponseBean<String> getCarInformationLevel3(ParameterBean parameterBean) {
        String id = parameterBean.getQueryParamKeyValueMap().get(Constants.ID);
        ResponseBean<String> responseBean =
                new ResponseBean<>(ErrorBasedSQLInjectionVulnerability.CAR_IS_NOT_PRESENT_RESPONSE);
        applicationJdbcTemplate.query(
                (conn) -> conn.prepareStatement("select * from cars where id=?"),
                (prepareStatement) -> {
                    prepareStatement.setString(1, id);
                },
                (rs) -> {
                    if (rs.next()) {
                        responseBean.setBody(CAR_IS_PRESENT_RESPONSE);
                    }
                    return null;
                });
        return responseBean;
    }
}
