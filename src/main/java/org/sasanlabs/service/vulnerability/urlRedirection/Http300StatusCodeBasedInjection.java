package org.sasanlabs.service.vulnerability.urlRedirection;

import java.net.MalformedURLException;
import java.net.URL;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import org.sasanlabs.internal.utility.GenericUtils;
import org.sasanlabs.internal.utility.LevelEnum;
import org.sasanlabs.internal.utility.annotations.VulnerabilityLevel;
import org.sasanlabs.internal.utility.annotations.VulnerableServiceRestEndPoint;
import org.sasanlabs.service.bean.ResponseBean;
import org.sasanlabs.service.vulnerability.ICustomVulnerableEndPoint;
import org.sasanlabs.service.vulnerability.ParameterBean;
import org.sasanlabs.vulnerability.types.VulnerabilityType;

/** @author KSASAN preetkaran20@gmail.com */
@VulnerableServiceRestEndPoint(
        descriptionLabel = "URL_REDIRECTION_LOCATION_HEADER_INJECTION",
        value = "Http300StatusCodeBasedInjection",
        type = {VulnerabilityType.URL_REDIRECT})
public class Http300StatusCodeBasedInjection implements ICustomVulnerableEndPoint {

    private static final String LOCATION_HEADER_KEY = "LOCATION";

    private static final String REFERER = "referer";

    @VulnerabilityLevel(
            value = LevelEnum.LEVEL_1,
            descriptionLabel = "URL_REDIRECTION_URL_PARAMETER_INJECTION_INTO_LOCATION_HEADER")
    public ResponseBean<?> getVulnerablePayloadLevelUnsecure(ParameterBean parameterBean) {
        Map<String, List<String>> headerParam = new LinkedHashMap<>();
        Iterator<Entry<String, String>> iterator =
                parameterBean.getQueryParamKeyValueMap().entrySet().iterator();
        if (iterator.hasNext()) {
            Entry<String, String> entry = iterator.next();
            headerParam.put(LOCATION_HEADER_KEY, new ArrayList<>());
            headerParam.get(LOCATION_HEADER_KEY).add(entry.getValue());
        }
        if (headerParam.containsKey(LOCATION_HEADER_KEY)) {
            return new ResponseBean<>(302, headerParam);
        } else {
            return new ResponseBean<>(
                    200, GenericUtils.wrapPayloadInGenericVulnerableAppTemplate(""));
        }
    }

    // Just a match so can be included as a queryparam of a Malicious site.
    @VulnerabilityLevel(
            value = LevelEnum.LEVEL_2,
            descriptionLabel =
                    "URL_REDIRECTION_URL_PARAMETER_INJECTION_INTO_LOCATION_HEADER_IF_CONTAINS_REQUEST_DOMAIN")
    public ResponseBean<?> getVulnerablePayloadLevelLow(ParameterBean parameterBean)
            throws MalformedURLException {
        Map<String, List<String>> headerParam = new LinkedHashMap<>();
        Iterator<Entry<String, String>> iterator =
                parameterBean.getQueryParamKeyValueMap().entrySet().iterator();
        if (iterator.hasNext()) {
            Entry<String, String> entry = iterator.next();
            URL requestUrl = new URL(parameterBean.getUrl());
            if (entry.getValue().contains(requestUrl.getAuthority())) {
                headerParam.put(LOCATION_HEADER_KEY, new ArrayList<>());
                headerParam.get(LOCATION_HEADER_KEY).add(entry.getValue());
            }
        }
        if (headerParam.containsKey(LOCATION_HEADER_KEY)) {
            return new ResponseBean<>(302, headerParam);
        } else {
            return new ResponseBean<>(
                    200, GenericUtils.wrapPayloadInGenericVulnerableAppTemplate(""));
        }
    }

    // Change in protocol is a problem here.
    @VulnerabilityLevel(
            value = LevelEnum.LEVEL_3,
            descriptionLabel =
                    "URL_REDIRECTION_URL_PARAMETER_INJECTION_INTO_LOCATION_HEADER_IF_DOMAIN_MATCHES")
    public ResponseBean<?> getVulnerablePayloadLevelMedium(ParameterBean parameterBean)
            throws MalformedURLException {
        Map<String, List<String>> headerParam = new LinkedHashMap<>();
        Iterator<Entry<String, String>> iterator =
                parameterBean.getQueryParamKeyValueMap().entrySet().iterator();
        if (iterator.hasNext()) {
            Entry<String, String> entry = iterator.next();
            URL parameterUrl = new URL(entry.getValue());
            URL requestUrl = new URL(parameterBean.getUrl());
            if (parameterUrl.getAuthority().equals(requestUrl.getAuthority())) {
                headerParam.put(LOCATION_HEADER_KEY, new ArrayList<>());
                headerParam.get(LOCATION_HEADER_KEY).add(entry.getValue());
            }
        }
        if (headerParam.containsKey(LOCATION_HEADER_KEY)) {
            return new ResponseBean<>(302, headerParam);
        } else {
            return new ResponseBean<>(
                    200, GenericUtils.wrapPayloadInGenericVulnerableAppTemplate(""));
        }
    }

    // Not that good, best is not taking values from Parameters
    @VulnerabilityLevel(
            value = LevelEnum.LEVEL_4,
            descriptionLabel =
                    "URL_REDIRECTION_URL_PARAMETER_INJECTION_INTO_LOCATION_HEADER_IF_DOMAIN_AND_PROTOCOL_MATCHES")
    public ResponseBean<?> getVulnerablePayloadLevelHigh(ParameterBean parameterBean)
            throws MalformedURLException {
        Map<String, List<String>> headerParam = new LinkedHashMap<>();
        Iterator<Entry<String, String>> iterator =
                parameterBean.getQueryParamKeyValueMap().entrySet().iterator();
        if (iterator.hasNext()) {
            Entry<String, String> entry = iterator.next();
            URL parameterUrl = new URL(entry.getValue());
            URL requestUrl = new URL(parameterBean.getUrl());
            if (parameterUrl.getAuthority().equals(requestUrl.getAuthority())
                    && parameterUrl.getProtocol().equals(requestUrl.getProtocol())) {
                headerParam.put(LOCATION_HEADER_KEY, new ArrayList<>());
                headerParam.get(LOCATION_HEADER_KEY).add(entry.getValue());
            }
        }
        if (headerParam.containsKey(LOCATION_HEADER_KEY)) {
            return new ResponseBean<>(302, headerParam);
        } else {
            return new ResponseBean<>(
                    200, GenericUtils.wrapPayloadInGenericVulnerableAppTemplate(""));
        }
    }

    // Depending on Referer Header
    @VulnerabilityLevel(
            value = LevelEnum.LEVEL_5,
            descriptionLabel = "URL_REDIRECTION_INJECTION_BASED_ON_REFERER_HEADER")
    public ResponseBean<?> getVulnerablePayloadLevelHigh1(ParameterBean parameterBean)
            throws MalformedURLException {
        Map<String, List<String>> headerParam = new LinkedHashMap<>();
        List<String> headerValues = parameterBean.getRequestHeadersMap().get(REFERER);
        if (headerValues != null && headerValues.size() > 0) {
            headerParam.put(LOCATION_HEADER_KEY, new ArrayList<>());
            headerParam.get(LOCATION_HEADER_KEY).add(headerValues.get(0));
            return new ResponseBean<>(302, headerParam);
        } else {
            return new ResponseBean<>(
                    200, GenericUtils.wrapPayloadInGenericVulnerableAppTemplate(""));
        }
    }

    @VulnerabilityLevel(
            value = LevelEnum.SECURE,
            descriptionLabel = "URL_REDIRECTION_NO_INJECTION_UNTRUSTED_DATA")
    public ResponseBean<?> getVulnerablePayloadLevelSecure(ParameterBean parameterBean)
            throws MalformedURLException {
        Map<String, List<String>> headerParam = new LinkedHashMap<>();
        headerParam.put(LOCATION_HEADER_KEY, Arrays.asList("/"));
        return new ResponseBean<>(302, headerParam);
    }
}
