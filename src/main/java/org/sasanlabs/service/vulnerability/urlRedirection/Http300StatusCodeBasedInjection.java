package org.sasanlabs.service.vulnerability.urlRedirection;

import java.net.MalformedURLException;
import java.net.URL;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import org.sasanlabs.internal.utility.GenericUtils;
import org.sasanlabs.internal.utility.LevelEnum;
import org.sasanlabs.internal.utility.annotations.VulnerableAppRequestMapping;
import org.sasanlabs.internal.utility.annotations.VulnerableAppRestController;
import org.sasanlabs.vulnerability.types.VulnerabilityType;
import org.springframework.http.HttpStatus;
import org.springframework.http.RequestEntity;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.RequestParam;

// http://projects.webappsec.org/w/page/13246981/URL%20Redirector%20Abuse
/** @author KSASAN preetkaran20@gmail.com */
@VulnerableAppRestController(
        descriptionLabel = "URL_REDIRECTION_LOCATION_HEADER_INJECTION",
        value = "Http300StatusCodeBasedInjection",
        type = {VulnerabilityType.URL_REDIRECT})
public class Http300StatusCodeBasedInjection {

    private static final String LOCATION_HEADER_KEY = "LOCATION";

    private static final String REFERER = "referer";

    @VulnerableAppRequestMapping(
            value = LevelEnum.LEVEL_1,
            descriptionLabel = "URL_REDIRECTION_URL_PARAMETER_INJECTION_INTO_LOCATION_HEADER")
    public ResponseEntity<?> getVulnerablePayloadLevelUnsecure(
            @RequestParam Map<String, String> queryParams) {
        Map<String, List<String>> headerParam = new LinkedHashMap<>();
        Iterator<Entry<String, String>> iterator = queryParams.entrySet().iterator();
        if (iterator.hasNext()) {
            Entry<String, String> entry = iterator.next();
            headerParam.put(LOCATION_HEADER_KEY, new ArrayList<>());
            headerParam.get(LOCATION_HEADER_KEY).add(entry.getValue());
        }
        if (headerParam.containsKey(LOCATION_HEADER_KEY)) {
            return new ResponseEntity<>(headerParam, HttpStatus.FOUND);
        } else {
            return new ResponseEntity<>(
                    GenericUtils.wrapPayloadInGenericVulnerableAppTemplate(""), HttpStatus.OK);
        }
    }

    // Just a match so can be included as a queryparam of a Malicious site.
    @VulnerableAppRequestMapping(
            value = LevelEnum.LEVEL_2,
            descriptionLabel =
                    "URL_REDIRECTION_URL_PARAMETER_INJECTION_INTO_LOCATION_HEADER_IF_CONTAINS_REQUEST_DOMAIN")
    public ResponseEntity<?> getVulnerablePayloadLevelLow(
            RequestEntity<String> requestEntity, @RequestParam Map<String, String> queryParams)
            throws MalformedURLException {
        Map<String, List<String>> headerParam = new LinkedHashMap<>();
        Iterator<Entry<String, String>> iterator = queryParams.entrySet().iterator();
        if (iterator.hasNext()) {
            Entry<String, String> entry = iterator.next();
            URL requestUrl = new URL(requestEntity.getUrl().toString());
            if (entry.getValue().contains(requestUrl.getAuthority())) {
                headerParam.put(LOCATION_HEADER_KEY, new ArrayList<>());
                headerParam.get(LOCATION_HEADER_KEY).add(entry.getValue());
            }
        }
        if (headerParam.containsKey(LOCATION_HEADER_KEY)) {
            return new ResponseEntity<>(headerParam, HttpStatus.FOUND);
        } else {
            return new ResponseEntity<>(
                    GenericUtils.wrapPayloadInGenericVulnerableAppTemplate(""), HttpStatus.OK);
        }
    }

    // Change in protocol is a problem here.
    @VulnerableAppRequestMapping(
            value = LevelEnum.LEVEL_3,
            descriptionLabel =
                    "URL_REDIRECTION_URL_PARAMETER_INJECTION_INTO_LOCATION_HEADER_IF_DOMAIN_MATCHES")
    public ResponseEntity<?> getVulnerablePayloadLevelMedium(
            RequestEntity<String> requestEntity, @RequestParam Map<String, String> queryParams)
            throws MalformedURLException {
        Map<String, List<String>> headerParam = new LinkedHashMap<>();
        Iterator<Entry<String, String>> iterator = queryParams.entrySet().iterator();
        if (iterator.hasNext()) {
            Entry<String, String> entry = iterator.next();
            URL parameterUrl = new URL(entry.getValue());
            URL requestUrl = new URL(requestEntity.getUrl().toString());
            if (parameterUrl.getAuthority().equals(requestUrl.getAuthority())) {
                headerParam.put(LOCATION_HEADER_KEY, new ArrayList<>());
                headerParam.get(LOCATION_HEADER_KEY).add(entry.getValue());
            }
        }
        if (headerParam.containsKey(LOCATION_HEADER_KEY)) {
            return new ResponseEntity<>(headerParam, HttpStatus.FOUND);
        } else {
            return new ResponseEntity<>(
                    GenericUtils.wrapPayloadInGenericVulnerableAppTemplate(""), HttpStatus.OK);
        }
    }

    // Not that good, best is not taking values from Parameters
    @VulnerableAppRequestMapping(
            value = LevelEnum.LEVEL_4,
            descriptionLabel =
                    "URL_REDIRECTION_URL_PARAMETER_INJECTION_INTO_LOCATION_HEADER_IF_DOMAIN_AND_PROTOCOL_MATCHES")
    public ResponseEntity<?> getVulnerablePayloadLevelHigh(
            RequestEntity<String> requestEntity, @RequestParam Map<String, String> queryParams)
            throws MalformedURLException {
        Map<String, List<String>> headerParam = new LinkedHashMap<>();
        Iterator<Entry<String, String>> iterator = queryParams.entrySet().iterator();
        if (iterator.hasNext()) {
            Entry<String, String> entry = iterator.next();
            URL parameterUrl = new URL(entry.getValue());
            URL requestUrl = new URL(requestEntity.getUrl().toString());
            if (parameterUrl.getAuthority().equals(requestUrl.getAuthority())
                    && parameterUrl.getProtocol().equals(requestUrl.getProtocol())) {
                headerParam.put(LOCATION_HEADER_KEY, new ArrayList<>());
                headerParam.get(LOCATION_HEADER_KEY).add(entry.getValue());
            }
        }
        if (headerParam.containsKey(LOCATION_HEADER_KEY)) {
            return new ResponseEntity<>(headerParam, HttpStatus.FOUND);
        } else {
            return new ResponseEntity<>(
                    GenericUtils.wrapPayloadInGenericVulnerableAppTemplate(""), HttpStatus.OK);
        }
    }

    // Depending on Referer Header
    @VulnerableAppRequestMapping(
            value = LevelEnum.LEVEL_5,
            descriptionLabel = "URL_REDIRECTION_INJECTION_BASED_ON_REFERER_HEADER")
    public ResponseEntity<?> getVulnerablePayloadLevelHigh1(
            RequestEntity<String> requestEntity, @RequestParam Map<String, String> queryParams)
            throws MalformedURLException {
        Map<String, List<String>> headerParam = new LinkedHashMap<>();
        List<String> headerValues = requestEntity.getHeaders().get(REFERER);
        if (headerValues != null && headerValues.size() > 0) {
            headerParam.put(LOCATION_HEADER_KEY, new ArrayList<>());
            headerParam.get(LOCATION_HEADER_KEY).add(headerValues.get(0));
            return new ResponseEntity<>(headerParam, HttpStatus.FOUND);
        } else {
            return new ResponseEntity<>(
                    GenericUtils.wrapPayloadInGenericVulnerableAppTemplate(""), HttpStatus.OK);
        }
    }

    //    @VulnerableAppRequestMapping(
    //            value = LevelEnum.SECURE,
    //            descriptionLabel = "URL_REDIRECTION_NO_INJECTION_UNTRUSTED_DATA")
    public ResponseEntity<?> getVulnerablePayloadLevelSecure(
            @RequestParam Map<String, String> queryParams) throws MalformedURLException {
        Map<String, List<String>> headerParam = new LinkedHashMap<>();
        headerParam.put(LOCATION_HEADER_KEY, Arrays.asList("/"));
        return new ResponseEntity<>(headerParam, HttpStatus.FOUND);
    }
}
