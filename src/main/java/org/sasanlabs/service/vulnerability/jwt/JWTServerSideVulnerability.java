package org.sasanlabs.service.vulnerability.jwt;

import java.io.UnsupportedEncodingException;
import java.util.Arrays;
import java.util.List;
import java.util.Optional;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.sasanlabs.internal.utility.GenericUtils;
import org.sasanlabs.internal.utility.LevelEnum;
import org.sasanlabs.internal.utility.annotations.VulnerabilityLevel;
import org.sasanlabs.internal.utility.annotations.VulnerableServiceRestEndPoint;
import org.sasanlabs.service.bean.ResponseBean;
import org.sasanlabs.service.exception.ServiceApplicationException;
import org.sasanlabs.service.vulnerability.ICustomVulnerableEndPoint;
import org.sasanlabs.service.vulnerability.ParameterBean;
import org.sasanlabs.service.vulnerability.jwt.keys.JWTLibrary;
import org.sasanlabs.service.vulnerability.jwt.keys.KeyStrength;
import org.sasanlabs.service.vulnerability.jwt.keys.SymmetricAlgorithmKMS;
import org.sasanlabs.service.vulnerability.jwt.keys.SymmetricAlgorithmKey;
import org.sasanlabs.vulnerability.types.VulnerabilityType;
import org.springframework.beans.factory.annotation.Autowired;

/**
 * JWT server side implementation issues and remediations. Issues like: 1. Weak
 * HMAC key 2. none algorithm attack 3. Weak Hash algorithm 4. tweak Algorithm
 * and Key.
 * 
 * {@link https://github.com/SasanLabs/JWTExtension/blob/master/BrainStorming.md}
 * 
 * @author KSASAN preetkaran20@gmail.com
 */

@VulnerableServiceRestEndPoint(descriptionLabel = "JWT_INJECTION_VULNERABILITY", value = "JWTServerSideVulnerability", type = {
		VulnerabilityType.JWT })
public class JWTServerSideVulnerability implements ICustomVulnerableEndPoint {

	private ParameterBean parameterBean;

	@Autowired
	private ILibBasedJWTGenerator libBasedJWTGenerator;

	@Autowired
	private IJWTValidator jwtValidator;

	private static final transient Logger LOGGER = LogManager.getLogger(JWTServerSideVulnerability.class);

	@Override
	public void setParameterBean(ParameterBean paramBean) {
		this.parameterBean = paramBean;
	}

	@VulnerabilityLevel(value = LevelEnum.LEVEL_1, descriptionLabel = "URL_BASED_JWT_VULNERABILITY")
	public ResponseBean getVulnerablePayloadLevelUnsecure()
			throws UnsupportedEncodingException, ServiceApplicationException {
		SymmetricAlgorithmKMS symmetricAlgorithmKMS = new SymmetricAlgorithmKMS();
		Optional<SymmetricAlgorithmKey> symmetricAlgorithmKey = symmetricAlgorithmKMS.getKey("HS256", KeyStrength.LOW,
				JWTLibrary.CUSTOM);
		LOGGER.error(symmetricAlgorithmKey.isPresent() + " " + symmetricAlgorithmKey.get());
		String token = this.parameterBean.getQueryParamKeyValueMap().get("JWTToken");
		if (token != null) {
			boolean isValid = jwtValidator.validateBasedOnCustomLib(token, JWTLibrary.CUSTOM, KeyStrength.LOW, "HS256");
			return new ResponseBean(GenericUtils.wrapPayloadInGenericVulnerableAppTemplate("" + isValid));
		} else {
			token = libBasedJWTGenerator.getJWTToken_Custom_HS256(JWTUtils.HMAC_TOKEN_TO_BE_SIGNED,
					JWTUtils.getBytes(symmetricAlgorithmKey.get().getKey()));
			return new ResponseBean(GenericUtils.wrapPayloadInGenericVulnerableAppTemplate(token));
		}
	}

	@VulnerabilityLevel(value = LevelEnum.LEVEL_2, descriptionLabel = "COOKIE_WITHOUT_HTTPONLY_BASED_JWT_VULNERABILITY")
	public ResponseBean getVulnerablePayloadLevelUnsecure2CookieBased()
			throws UnsupportedEncodingException, ServiceApplicationException {
		SymmetricAlgorithmKMS symmetricAlgorithmKMS = new SymmetricAlgorithmKMS();
		Optional<SymmetricAlgorithmKey> symmetricAlgorithmKey = symmetricAlgorithmKMS.getKey("HS256", KeyStrength.LOW,
				JWTLibrary.CUSTOM);
		LOGGER.error(symmetricAlgorithmKey.isPresent() + " " + symmetricAlgorithmKey.get());
		List<String> tokens = this.parameterBean.getRequestHeadersMap().get("cookie");
		if (tokens != null) {
			for(String token: tokens) {
				String[] cookieKeyValue = token.split(JWTUtils.BASE64_PADDING_CHARACTER_REGEX);
				if(cookieKeyValue[0].equals("JWTToken")) {
					boolean isValid = jwtValidator.validateBasedOnCustomLib(cookieKeyValue[1], JWTLibrary.CUSTOM, KeyStrength.LOW, "HS256");
					ResponseBean responseBean = new ResponseBean(GenericUtils.wrapPayloadInGenericVulnerableAppTemplate("" + isValid));
					responseBean.getResponseHeaders().put("Set-Cookie", Arrays.asList(token));
					return responseBean;
				}
			}
		} 
			
		String token = libBasedJWTGenerator.getJWTToken_Custom_HS256(JWTUtils.HMAC_TOKEN_TO_BE_SIGNED,
				JWTUtils.getBytes(symmetricAlgorithmKey.get().getKey()));
		ResponseBean responseBean = new ResponseBean(GenericUtils.wrapPayloadInGenericVulnerableAppTemplate(token));
		responseBean.getResponseHeaders().put("Set-Cookie", Arrays.asList("JWTToken=" + token));
		return responseBean;
		
	}

	@VulnerabilityLevel(value = LevelEnum.LEVEL_3, descriptionLabel = "COOKIE_WITH_HTTPONLY_WITHOUT_SECURE_FLAG_BASED_JWT_VULNERABILITY")
	public ResponseBean getVulnerablePayloadLevelUnsecure3CookieBased()
			throws UnsupportedEncodingException, ServiceApplicationException {
		SymmetricAlgorithmKMS symmetricAlgorithmKMS = new SymmetricAlgorithmKMS();
		Optional<SymmetricAlgorithmKey> symmetricAlgorithmKey = symmetricAlgorithmKMS.getKey("HS256", KeyStrength.LOW,
				JWTLibrary.CUSTOM);
		LOGGER.error(symmetricAlgorithmKey.isPresent() + " " + symmetricAlgorithmKey.get());
		List<String> tokens = this.parameterBean.getRequestHeadersMap().get("cookie");
		if (tokens != null) {
			for(String token: tokens) {
				String[] cookieKeyValue = token.split(JWTUtils.BASE64_PADDING_CHARACTER_REGEX);
				if(cookieKeyValue[0].equals("JWTToken")) {
					boolean isValid = jwtValidator.validateBasedOnCustomLib(cookieKeyValue[1], JWTLibrary.CUSTOM, KeyStrength.LOW, "HS256");
					ResponseBean responseBean = new ResponseBean(GenericUtils.wrapPayloadInGenericVulnerableAppTemplate("" + isValid));
					responseBean.getResponseHeaders().put("Set-Cookie", Arrays.asList(token + "; httponly"));
					return responseBean;
				}
			}
		} 
			
		String token = libBasedJWTGenerator.getJWTToken_Custom_HS256(JWTUtils.HMAC_TOKEN_TO_BE_SIGNED,
				JWTUtils.getBytes(symmetricAlgorithmKey.get().getKey()));
		ResponseBean responseBean = new ResponseBean(GenericUtils.wrapPayloadInGenericVulnerableAppTemplate(token));
		responseBean.getResponseHeaders().put("Set-Cookie", Arrays.asList("JWTToken=" + token + "; httponly"));
		return responseBean;
		
	}

	
	@VulnerabilityLevel(value = LevelEnum.LEVEL_4, descriptionLabel = "URL_BASED_JWT_VULNERABILITY")
	public ResponseBean getVulnerablePayloadLevel3() throws UnsupportedEncodingException {
		SymmetricAlgorithmKMS symmetricAlgorithmKMS = new SymmetricAlgorithmKMS();
		Optional<SymmetricAlgorithmKey> symmetricAlgorithmKey = symmetricAlgorithmKMS.getKey("HS256", KeyStrength.LOW,
				JWTLibrary.JJWT);
		LOGGER.error(symmetricAlgorithmKey.isPresent() + " " + symmetricAlgorithmKey.get());
		String token = this.parameterBean.getQueryParamKeyValueMap().get("JWTToken");
		if (token != null) {
			boolean isValid = jwtValidator.validateBasedOnJJWTLib(token, JWTLibrary.JJWT, KeyStrength.LOW, "HS256");
			return new ResponseBean(GenericUtils.wrapPayloadInGenericVulnerableAppTemplate("" + isValid));
		} else {
			token = libBasedJWTGenerator.getJWTTokenJJWTLib_HS256("",
					JWTUtils.getBytes(symmetricAlgorithmKey.get().getKey()));
			return new ResponseBean(GenericUtils.wrapPayloadInGenericVulnerableAppTemplate(token));
		}
	}
}
