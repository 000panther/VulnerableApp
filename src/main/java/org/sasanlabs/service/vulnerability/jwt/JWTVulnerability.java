package org.sasanlabs.service.vulnerability.jwt;

import static org.sasanlabs.service.vulnerability.jwt.bean.JWTUtils.GENERIC_BASE64_ENCODED_PAYLOAD;

import com.nimbusds.jose.jwk.JWK;
import com.nimbusds.jose.jwk.KeyUse;
import com.nimbusds.jose.jwk.RSAKey;
import java.io.UnsupportedEncodingException;
import java.security.KeyPair;
import java.security.interfaces.RSAPrivateKey;
import java.security.interfaces.RSAPublicKey;
import java.util.Arrays;
import java.util.List;
import java.util.Optional;
import java.util.UUID;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.json.JSONObject;
import org.sasanlabs.internal.utility.LevelEnum;
import org.sasanlabs.internal.utility.annotations.AttackVector;
import org.sasanlabs.internal.utility.annotations.RequestParameterLocation;
import org.sasanlabs.internal.utility.annotations.VulnerabilityLevel;
import org.sasanlabs.internal.utility.annotations.VulnerableServiceRestEndPoint;
import org.sasanlabs.service.bean.ResponseBean;
import org.sasanlabs.service.exception.ServiceApplicationException;
import org.sasanlabs.service.vulnerability.ICustomVulnerableEndPoint;
import org.sasanlabs.service.vulnerability.ParameterBean;
import org.sasanlabs.service.vulnerability.bean.GenericVulnerabilityResponseBean;
import org.sasanlabs.service.vulnerability.jwt.bean.JWTUtils;
import org.sasanlabs.service.vulnerability.jwt.keys.JWTAlgorithmKMS;
import org.sasanlabs.service.vulnerability.jwt.keys.KeyStrength;
import org.sasanlabs.service.vulnerability.jwt.keys.SymmetricAlgorithmKey;
import org.sasanlabs.vulnerability.types.VulnerabilitySubType;
import org.sasanlabs.vulnerability.types.VulnerabilityType;
import org.springframework.beans.factory.annotation.Autowired;

/**
 * JWT client and server side implementation issues and remediations. Server side issues like: 1.
 * Weak HMAC key 2. none algorithm attack 3. Weak Hash algorithm 4. tweak Algorithm and Key.
 *
 * <p>Client side issues like: 1. Storing jwt in local storage/session storage hence if attacked
 * with XSS can be quite dangerous. 2. Storing jwt in cookies without httponly/secure flags or
 * cookie prefixes.
 *
 * <p>{@link https://github.com/SasanLabs/JWTExtension/blob/master/BrainStorming.md}
 *
 * @author KSASAN preetkaran20@gmail.com
 */
@VulnerableServiceRestEndPoint(
        descriptionLabel = "JWT_INJECTION_VULNERABILITY",
        value = "JWTVulnerability",
        type = {VulnerabilityType.VULNERABLE_JWT_IMPLMENTATION})
public class JWTVulnerability implements ICustomVulnerableEndPoint {

    @Autowired private IJWTTokenGenerator libBasedJWTGenerator;

    @Autowired private IJWTValidator jwtValidator;

    private static final transient Logger LOGGER = LogManager.getLogger(JWTVulnerability.class);

    private static final String JWT = "JWT";
    private static final String JWT_COOKIE_KEY = JWT + "=";

    /**
     * Constant JWT's. These are precomputed because we have to return Sample Values for helping
     * scanners to know about the format of the input so that they can attack accordingly. we can
     * precompute these tokens because content of token is static and also keys are static.
     */
    // Constant JWT HS256 Signed with High Strength Key.
    private static final String PRECOMPUTED_JWT_HS256_HIGH_STRENGTH =
            "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.MZiW2KkIRI6GhKsu16Me7-3IpS4nBw1W47CW67QAqS0";
    // Constant JWT HS256 Signed with LOW Strength Key.
    private static final String PRECOMPUTED_JWT_HS256_LOW_STRENGTH =
            "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.kXSdJhhUKTJemgs8O0rfIJmUaxoSIDdClL_OPmaC7Eo";
    // Constant JWT RS256 Signed
    private static final String PRECOMPUTED_JWT_RS256 =
            "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWUsImlhdCI6MTUxNjIzOTAyMn0"
                    + ".k5_ifQHwxXrjjg0CNExhTzkPLOk88UA3C3KlQLc2AdGQl4kXGOy46f2DZsJGopy_cT1DSVl0HfzkDhm6RTutv7fGdr7tjqwWBPu-oIBQQytVejDW4WyyuozjsWrvr"
                    + "OHGMFyaO7FHEufGLRJ0ZAZ0SC4R-IAor8ggWhKaRqanKTZfTBQZWaGs3js5B7xcr2LUBRMNdGFJEJHdbMa3LtcmU-plmltesJpUcmoorFNjmt5li9xrpBSSf5-5ruj"
                    + "P1lp5lEqwrRTCl07NQVXlvh6plZYR5-3WJ2IFSBEqkz9ztUNCSTHOxVF_5LG05NxhwkVsxUvcvhGLWsMtiA8yg2-P-g";
    // Constant JWT RS256 signed with JWK
    private static final String PRECOMPUTED_JWT_RS256_WITH_JWK =
            "eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsImp3ayI6eyJrdHkiOiJSU0EiLCJlIjoiQVFBQiIsInVzZSI6InNpZyIsImtpZCI6IjhmYzgzYmE1LTRmNjUtNDg4ZS05Y"
                    + "jQ5LTUyZGNhOThiZTNiZiIsIm4iOiJ4dk9ncUVyUW1XNEU0dGN3QXZQdnp1WUs0RGxxMlYzaHNKcFJwQjJyeVdwa3EydnlXeVcySlBJc2FUMjFvUkhWbmxSbzZEUmpw"
                    + "ZTROd3dDb1NYUTRlVS1weXRpWG54SjdKSlNlWlVpcmIwR0NsTGMzQ3VWSDZEUzl2Z3BLcEJDMW56OHRSbkFvSDRhRDNGQVFTR3EzLU1vbm1DZ0V6X1hTOTFGeUJKS2F"
                    + "qR2pidFBka0lvYzZaWUcxRjNCTXdPQmlFbUZTY2dMYmhGMTg5MVp1aDluSUNJdmJMM3hvSkJXTHRRLTZsVmZxWVZ5TWF3RlZPSFFkV1lXbXJpeXJNY2wyak5ueEszcT"
                    + "E5UXYzcWdESTA3dUd4aFhXbWgwYTlPLUgyRHFiclR0X0M1ZFJPeXZONDhVOVI0WXlveE03OTdSejk0WHVJMUhqQlVGY1Z4RXlrX013SVEifX0.eyJzdWIiOiIxMjM0N"
                    + "TY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWUsImlhdCI6MTUxNjIzOTAyMn0.rsEJeVbj1Bukf56CMWZvGHft3-lJO0e9EhrCkrzVwHBJoB8ZKR8x"
                    + "CINRtpDl327jPbTU_ouW4Dq6yCmhtrytxDsjzznUlHwKPiO7znI9oiWL98ADCJVPrlXL5VvyCk9bsJ78ADddDgTO1jYRcO6BJ2628hZZEOKBIeL0PtEwe1_1jLHEFqf"
                    + "w944gGWVmwqCf3LZPZVbVZ7icLPqRABXL7_VPId2bQcc7wNlvNB3dsQzvYD31KoCpGgcuYAoql46fTZHI5v2_QxYCJH6Sp-iep9O-iN2tlHdM6dnUIQO8MGV7GWsxeL"
                    + "UAqsStxiLGNZYz-uDYPr6-RieCTu5nM7KbaQ";

    private ResponseBean<GenericVulnerabilityResponseBean<String>> getJWTResponseBean(
            boolean isValid, String jwtToken, boolean includeToken) {
        GenericVulnerabilityResponseBean<String> genericVulnerabilityResponseBean;
        if (includeToken) {
            genericVulnerabilityResponseBean =
                    new GenericVulnerabilityResponseBean<String>(jwtToken, isValid);
        } else {
            genericVulnerabilityResponseBean =
                    new GenericVulnerabilityResponseBean<String>(null, isValid);
        }
        if (!isValid) {
            ResponseBean<GenericVulnerabilityResponseBean<String>> responseBean =
                    new ResponseBean<GenericVulnerabilityResponseBean<String>>(
                            genericVulnerabilityResponseBean);
            responseBean.setHttpStatusCode(401);
            return responseBean;
        }
        return new ResponseBean<GenericVulnerabilityResponseBean<String>>(
                genericVulnerabilityResponseBean);
    }

    @AttackVector(
            vulnerabilityExposed = VulnerabilitySubType.CLIENT_SIDE_VULNERABLE_JWT,
            description = "JWT_URL_EXPOSING_SECURE_INFORMATION")
    @VulnerabilityLevel(
            value = LevelEnum.LEVEL_1,
            descriptionLabel = "URL_CONTAINING_JWT_TOKEN",
            htmlTemplate = "LEVEL_1/JWT_Level1",
            parameterName = JWT,
            sampleValues = {PRECOMPUTED_JWT_HS256_HIGH_STRENGTH})
    public ResponseBean<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevelUnsecure(
            ParameterBean parameterBean)
            throws UnsupportedEncodingException, ServiceApplicationException {
        JWTAlgorithmKMS jwtAlgorithmKMS = new JWTAlgorithmKMS();
        Optional<SymmetricAlgorithmKey> symmetricAlgorithmKey =
                jwtAlgorithmKMS.getSymmetricAlgorithmKey(
                        JWTUtils.JWT_HMAC_SHA_256_ALGORITHM, KeyStrength.HIGH);
        LOGGER.error(symmetricAlgorithmKey.isPresent() + " " + symmetricAlgorithmKey.get());
        String token = parameterBean.getQueryParamKeyValueMap().get(JWT);
        if (token != null) {
            boolean isValid =
                    jwtValidator.customHMACValidator(
                            token,
                            JWTUtils.getBytes(symmetricAlgorithmKey.get().getKey()),
                            JWTUtils.JWT_HMAC_SHA_256_ALGORITHM);
            return this.getJWTResponseBean(isValid, token, !isValid);
        } else {
            token =
                    libBasedJWTGenerator.getHMACSignedJWTToken(
                            JWTUtils.HS256_TOKEN_TO_BE_SIGNED,
                            JWTUtils.getBytes(symmetricAlgorithmKey.get().getKey()),
                            JWTUtils.JWT_HMAC_SHA_256_ALGORITHM);
            return this.getJWTResponseBean(true, token, true);
        }
    }

    @AttackVector(
            vulnerabilityExposed = VulnerabilitySubType.CLIENT_SIDE_VULNERABLE_JWT,
            description = "COOKIE_CONTAINING_JWT_TOKEN_SECURITY_ATTRIBUTES_MISSING")
    @VulnerabilityLevel(
            value = LevelEnum.LEVEL_2,
            descriptionLabel = "COOKIE_CONTAINING_JWT_TOKEN",
            htmlTemplate = "LEVEL_2/JWT_Level2",
            parameterName = JWT,
            requestParameterLocation = RequestParameterLocation.COOKIE,
            sampleValues = {PRECOMPUTED_JWT_HS256_HIGH_STRENGTH})
    public ResponseBean<GenericVulnerabilityResponseBean<String>>
            getVulnerablePayloadLevelUnsecure2CookieBased(ParameterBean parameterBean)
                    throws UnsupportedEncodingException, ServiceApplicationException {
        JWTAlgorithmKMS jwtAlgorithmKMS = new JWTAlgorithmKMS();
        Optional<SymmetricAlgorithmKey> symmetricAlgorithmKey =
                jwtAlgorithmKMS.getSymmetricAlgorithmKey(
                        JWTUtils.JWT_HMAC_SHA_256_ALGORITHM, KeyStrength.HIGH);
        LOGGER.error(symmetricAlgorithmKey.isPresent() + " " + symmetricAlgorithmKey.get());
        List<String> tokens = parameterBean.getRequestHeadersMap().get("cookie");
        boolean isFetch = Boolean.valueOf(parameterBean.getQueryParamKeyValueMap().get("fetch"));
        if (!isFetch) {
            for (String token : tokens) {
                String[] cookieKeyValue = token.split(JWTUtils.BASE64_PADDING_CHARACTER_REGEX);
                if (cookieKeyValue[0].equals(JWT)) {
                    boolean isValid =
                            jwtValidator.customHMACValidator(
                                    cookieKeyValue[1],
                                    JWTUtils.getBytes(symmetricAlgorithmKey.get().getKey()),
                                    JWTUtils.JWT_HMAC_SHA_256_ALGORITHM);
                    ResponseBean<GenericVulnerabilityResponseBean<String>> responseBean =
                            this.getJWTResponseBean(isValid, token, !isValid);
                    responseBean.getResponseHeaders().put("Set-Cookie", Arrays.asList(token));
                    return responseBean;
                }
            }
        }

        String token =
                libBasedJWTGenerator.getHMACSignedJWTToken(
                        JWTUtils.HS256_TOKEN_TO_BE_SIGNED,
                        JWTUtils.getBytes(symmetricAlgorithmKey.get().getKey()),
                        JWTUtils.JWT_HMAC_SHA_256_ALGORITHM);
        ResponseBean<GenericVulnerabilityResponseBean<String>> responseBean =
                this.getJWTResponseBean(true, token, true);
        responseBean.getResponseHeaders().put("Set-Cookie", Arrays.asList(JWT_COOKIE_KEY + token));
        return responseBean;
    }

    @AttackVector(
            vulnerabilityExposed = VulnerabilitySubType.CLIENT_SIDE_VULNERABLE_JWT,
            description = "COOKIE_WITH_HTTPONLY_WITHOUT_SECURE_FLAG_BASED_JWT_VULNERABILITY")
    @VulnerabilityLevel(
            value = LevelEnum.LEVEL_3,
            descriptionLabel = "COOKIE_CONTAINING_JWT_TOKEN",
            htmlTemplate = "LEVEL_2/JWT_Level2",
            parameterName = JWT,
            requestParameterLocation = RequestParameterLocation.COOKIE,
            sampleValues = {PRECOMPUTED_JWT_HS256_HIGH_STRENGTH})
    public ResponseBean<GenericVulnerabilityResponseBean<String>>
            getVulnerablePayloadLevelUnsecure3CookieBased(ParameterBean parameterBean)
                    throws UnsupportedEncodingException, ServiceApplicationException {
        JWTAlgorithmKMS jwtAlgorithmKMS = new JWTAlgorithmKMS();
        Optional<SymmetricAlgorithmKey> symmetricAlgorithmKey =
                jwtAlgorithmKMS.getSymmetricAlgorithmKey(
                        JWTUtils.JWT_HMAC_SHA_256_ALGORITHM, KeyStrength.HIGH);
        LOGGER.error(symmetricAlgorithmKey.isPresent() + " " + symmetricAlgorithmKey.get());
        List<String> tokens = parameterBean.getRequestHeadersMap().get("cookie");
        boolean isFetch = Boolean.valueOf(parameterBean.getQueryParamKeyValueMap().get("fetch"));
        if (!isFetch) {
            for (String token : tokens) {
                String[] cookieKeyValue = token.split(JWTUtils.BASE64_PADDING_CHARACTER_REGEX);
                if (cookieKeyValue[0].equals(JWT)) {
                    boolean isValid =
                            jwtValidator.customHMACValidator(
                                    cookieKeyValue[1],
                                    JWTUtils.getBytes(symmetricAlgorithmKey.get().getKey()),
                                    JWTUtils.JWT_HMAC_SHA_256_ALGORITHM);
                    ResponseBean<GenericVulnerabilityResponseBean<String>> responseBean =
                            this.getJWTResponseBean(isValid, token, !isValid);
                    responseBean
                            .getResponseHeaders()
                            .put("Set-Cookie", Arrays.asList(token + "; httponly"));
                    return responseBean;
                }
            }
        }
        String token =
                libBasedJWTGenerator.getHMACSignedJWTToken(
                        JWTUtils.HS256_TOKEN_TO_BE_SIGNED,
                        JWTUtils.getBytes(symmetricAlgorithmKey.get().getKey()),
                        JWTUtils.JWT_HMAC_SHA_256_ALGORITHM);
        ResponseBean<GenericVulnerabilityResponseBean<String>> responseBean =
                this.getJWTResponseBean(true, token, true);
        responseBean
                .getResponseHeaders()
                .put("Set-Cookie", Arrays.asList(JWT_COOKIE_KEY + token + "; httponly"));
        return responseBean;
    }

    @AttackVector(
            vulnerabilityExposed = VulnerabilitySubType.CLIENT_SIDE_VULNERABLE_JWT,
            description = "COOKIE_WITH_HTTPONLY_WITHOUT_SECURE_FLAG_BASED_JWT_VULNERABILITY")
    @AttackVector(
            vulnerabilityExposed = VulnerabilitySubType.INSECURE_CONFIGURATION_JWT,
            description = "COOKIE_BASED_LOW_KEY_STRENGTH_JWT_VULNERABILITY")
    @VulnerabilityLevel(
            value = LevelEnum.LEVEL_4,
            descriptionLabel = "COOKIE_CONTAINING_JWT_TOKEN",
            htmlTemplate = "LEVEL_2/JWT_Level2",
            parameterName = JWT,
            requestParameterLocation = RequestParameterLocation.COOKIE,
            sampleValues = {PRECOMPUTED_JWT_HS256_LOW_STRENGTH})
    public ResponseBean<GenericVulnerabilityResponseBean<String>>
            getVulnerablePayloadLevelUnsecure4CookieBased(ParameterBean parameterBean)
                    throws UnsupportedEncodingException, ServiceApplicationException {
        JWTAlgorithmKMS jwtAlgorithmKMS = new JWTAlgorithmKMS();
        Optional<SymmetricAlgorithmKey> symmetricAlgorithmKey =
                jwtAlgorithmKMS.getSymmetricAlgorithmKey(
                        JWTUtils.JWT_HMAC_SHA_256_ALGORITHM, KeyStrength.LOW);
        LOGGER.error(symmetricAlgorithmKey.isPresent() + " " + symmetricAlgorithmKey.get());
        List<String> tokens = parameterBean.getRequestHeadersMap().get("cookie");
        boolean isFetch = Boolean.valueOf(parameterBean.getQueryParamKeyValueMap().get("fetch"));
        if (!isFetch) {
            for (String token : tokens) {
                String[] cookieKeyValue = token.split(JWTUtils.BASE64_PADDING_CHARACTER_REGEX);
                if (cookieKeyValue[0].equals(JWT)) {
                    boolean isValid =
                            jwtValidator.customHMACValidator(
                                    cookieKeyValue[1],
                                    JWTUtils.getBytes(symmetricAlgorithmKey.get().getKey()),
                                    JWTUtils.JWT_HMAC_SHA_256_ALGORITHM);
                    ResponseBean<GenericVulnerabilityResponseBean<String>> responseBean =
                            this.getJWTResponseBean(isValid, token, !isValid);
                    responseBean
                            .getResponseHeaders()
                            .put("Set-Cookie", Arrays.asList(token + "; httponly"));
                    return responseBean;
                }
            }
        }

        String token =
                libBasedJWTGenerator.getHMACSignedJWTToken(
                        JWTUtils.HS256_TOKEN_TO_BE_SIGNED,
                        JWTUtils.getBytes(symmetricAlgorithmKey.get().getKey()),
                        JWTUtils.JWT_HMAC_SHA_256_ALGORITHM);
        ResponseBean<GenericVulnerabilityResponseBean<String>> responseBean =
                this.getJWTResponseBean(true, token, true);
        responseBean
                .getResponseHeaders()
                .put("Set-Cookie", Arrays.asList(JWT_COOKIE_KEY + token + "; httponly"));
        return responseBean;
    }

    @AttackVector(
            vulnerabilityExposed = VulnerabilitySubType.CLIENT_SIDE_VULNERABLE_JWT,
            description = "COOKIE_WITH_HTTPONLY_WITHOUT_SECURE_FLAG_BASED_JWT_VULNERABILITY")
    @AttackVector(
            vulnerabilityExposed = {
                VulnerabilitySubType.SERVER_SIDE_VULNERABLE_JWT,
                VulnerabilitySubType.NULL_BYTE
            },
            description = "COOKIE_BASED_NULL_BYTE_JWT_VULNERABILITY")
    @VulnerabilityLevel(
            value = LevelEnum.LEVEL_5,
            descriptionLabel = "COOKIE_CONTAINING_JWT_TOKEN",
            htmlTemplate = "LEVEL_2/JWT_Level2",
            parameterName = JWT,
            requestParameterLocation = RequestParameterLocation.COOKIE,
            sampleValues = {PRECOMPUTED_JWT_HS256_HIGH_STRENGTH})
    public ResponseBean<GenericVulnerabilityResponseBean<String>>
            getVulnerablePayloadLevelUnsecure5CookieBased(ParameterBean parameterBean)
                    throws UnsupportedEncodingException, ServiceApplicationException {
        JWTAlgorithmKMS jwtAlgorithmKMS = new JWTAlgorithmKMS();
        Optional<SymmetricAlgorithmKey> symmetricAlgorithmKey =
                jwtAlgorithmKMS.getSymmetricAlgorithmKey(
                        JWTUtils.JWT_HMAC_SHA_256_ALGORITHM, KeyStrength.HIGH);
        LOGGER.error(symmetricAlgorithmKey.isPresent() + " " + symmetricAlgorithmKey.get());
        List<String> tokens = parameterBean.getRequestHeadersMap().get("cookie");
        boolean isFetch = Boolean.valueOf(parameterBean.getQueryParamKeyValueMap().get("fetch"));
        if (!isFetch) {
            for (String token : tokens) {
                String[] cookieKeyValue = token.split(JWTUtils.BASE64_PADDING_CHARACTER_REGEX);
                if (cookieKeyValue[0].equals(JWT)) {
                    boolean isValid =
                            jwtValidator.customHMACNullByteVulnerableValidator(
                                    cookieKeyValue[1],
                                    JWTUtils.getBytes(symmetricAlgorithmKey.get().getKey()),
                                    JWTUtils.JWT_HMAC_SHA_256_ALGORITHM);
                    ResponseBean<GenericVulnerabilityResponseBean<String>> responseBean =
                            this.getJWTResponseBean(isValid, token, !isValid);
                    responseBean
                            .getResponseHeaders()
                            .put("Set-Cookie", Arrays.asList(token + "; httponly"));
                    return responseBean;
                }
            }
        }

        String token =
                libBasedJWTGenerator.getHMACSignedJWTToken(
                        JWTUtils.HS256_TOKEN_TO_BE_SIGNED,
                        JWTUtils.getBytes(symmetricAlgorithmKey.get().getKey()),
                        JWTUtils.JWT_HMAC_SHA_256_ALGORITHM);
        ResponseBean<GenericVulnerabilityResponseBean<String>> responseBean =
                this.getJWTResponseBean(true, token, true);
        responseBean
                .getResponseHeaders()
                .put("Set-Cookie", Arrays.asList(JWT_COOKIE_KEY + token + "; httponly"));
        return responseBean;
    }

    @AttackVector(
            vulnerabilityExposed = VulnerabilitySubType.CLIENT_SIDE_VULNERABLE_JWT,
            description = "COOKIE_WITH_HTTPONLY_WITHOUT_SECURE_FLAG_BASED_JWT_VULNERABILITY")
    @AttackVector(
            vulnerabilityExposed = VulnerabilitySubType.SERVER_SIDE_VULNERABLE_JWT,
            description = "COOKIE_BASED_NONE_ALGORITHM_JWT_VULNERABILITY",
            curlPayload = "NONE_ALGORITHM_ATTACK_CURL_PAYLOAD")
    @VulnerabilityLevel(
            value = LevelEnum.LEVEL_6,
            descriptionLabel = "COOKIE_CONTAINING_JWT_TOKEN",
            htmlTemplate = "LEVEL_2/JWT_Level2",
            parameterName = JWT,
            requestParameterLocation = RequestParameterLocation.COOKIE,
            sampleValues = {PRECOMPUTED_JWT_HS256_HIGH_STRENGTH})
    public ResponseBean<GenericVulnerabilityResponseBean<String>>
            getVulnerablePayloadLevelUnsecure6CookieBased(ParameterBean parameterBean)
                    throws UnsupportedEncodingException, ServiceApplicationException {
        JWTAlgorithmKMS jwtAlgorithmKMS = new JWTAlgorithmKMS();
        Optional<SymmetricAlgorithmKey> symmetricAlgorithmKey =
                jwtAlgorithmKMS.getSymmetricAlgorithmKey(
                        JWTUtils.JWT_HMAC_SHA_256_ALGORITHM, KeyStrength.HIGH);
        LOGGER.error(symmetricAlgorithmKey.isPresent() + " " + symmetricAlgorithmKey.get());
        List<String> tokens = parameterBean.getRequestHeadersMap().get("cookie");
        boolean isFetch = Boolean.valueOf(parameterBean.getQueryParamKeyValueMap().get("fetch"));
        if (!isFetch) {
            for (String token : tokens) {
                String[] cookieKeyValue = token.split(JWTUtils.BASE64_PADDING_CHARACTER_REGEX);
                if (cookieKeyValue[0].equals(JWT)) {
                    boolean isValid =
                            jwtValidator.customHMACNoneAlgorithmVulnerableValidator(
                                    cookieKeyValue[1],
                                    JWTUtils.getBytes(symmetricAlgorithmKey.get().getKey()),
                                    JWTUtils.JWT_HMAC_SHA_256_ALGORITHM);
                    ResponseBean<GenericVulnerabilityResponseBean<String>> responseBean =
                            this.getJWTResponseBean(isValid, token, !isValid);
                    responseBean
                            .getResponseHeaders()
                            .put("Set-Cookie", Arrays.asList(token + "; httponly"));
                    return responseBean;
                }
            }
        }

        String token =
                libBasedJWTGenerator.getHMACSignedJWTToken(
                        JWTUtils.HS256_TOKEN_TO_BE_SIGNED,
                        JWTUtils.getBytes(symmetricAlgorithmKey.get().getKey()),
                        JWTUtils.JWT_HMAC_SHA_256_ALGORITHM);
        ResponseBean<GenericVulnerabilityResponseBean<String>> responseBean =
                this.getJWTResponseBean(true, token, true);
        responseBean
                .getResponseHeaders()
                .put("Set-Cookie", Arrays.asList(JWT_COOKIE_KEY + token + "; httponly"));
        return responseBean;
    }

    @AttackVector(
            vulnerabilityExposed = VulnerabilitySubType.CLIENT_SIDE_VULNERABLE_JWT,
            description = "COOKIE_WITH_HTTPONLY_WITHOUT_SECURE_FLAG_BASED_JWT_VULNERABILITY")
    @AttackVector(
            vulnerabilityExposed = VulnerabilitySubType.SERVER_SIDE_VULNERABLE_JWT,
            description = "COOKIE_BASED_KEY_CONFUSION_JWT_VULNERABILITY")
    @VulnerabilityLevel(
            value = LevelEnum.LEVEL_7,
            descriptionLabel = "COOKIE_CONTAINING_JWT_TOKEN",
            htmlTemplate = "LEVEL_2/JWT_Level2",
            parameterName = JWT,
            requestParameterLocation = RequestParameterLocation.COOKIE,
            sampleValues = {PRECOMPUTED_JWT_RS256})
    public ResponseBean<GenericVulnerabilityResponseBean<String>>
            getVulnerablePayloadLevelUnsecure7CookieBased(ParameterBean parameterBean)
                    throws UnsupportedEncodingException, ServiceApplicationException {
        JWTAlgorithmKMS jwtAlgorithmKMS = new JWTAlgorithmKMS();
        Optional<KeyPair> asymmetricAlgorithmKeyPair =
                jwtAlgorithmKMS.getAsymmetricAlgorithmKey("RS256");
        LOGGER.error(
                asymmetricAlgorithmKeyPair.isPresent() + " " + asymmetricAlgorithmKeyPair.get());
        List<String> tokens = parameterBean.getRequestHeadersMap().get("cookie");
        boolean isFetch = Boolean.valueOf(parameterBean.getQueryParamKeyValueMap().get("fetch"));
        if (!isFetch) {
            for (String token : tokens) {
                String[] cookieKeyValue = token.split(JWTUtils.BASE64_PADDING_CHARACTER_REGEX);
                if (cookieKeyValue[0].equals(JWT)) {
                    boolean isValid =
                            jwtValidator.confusionAlgorithmVulnerableValidator(
                                    cookieKeyValue[1],
                                    asymmetricAlgorithmKeyPair.get().getPublic());
                    ResponseBean<GenericVulnerabilityResponseBean<String>> responseBean =
                            this.getJWTResponseBean(isValid, token, !isValid);
                    responseBean
                            .getResponseHeaders()
                            .put("Set-Cookie", Arrays.asList(token + "; httponly"));
                    return responseBean;
                }
            }
        }

        String token =
                libBasedJWTGenerator.getJWTToken_RS256(
                        JWTUtils.RS256_TOKEN_TO_BE_SIGNED,
                        asymmetricAlgorithmKeyPair.get().getPrivate());
        ResponseBean<GenericVulnerabilityResponseBean<String>> responseBean =
                this.getJWTResponseBean(true, token, true);
        responseBean
                .getResponseHeaders()
                .put("Set-Cookie", Arrays.asList(JWT_COOKIE_KEY + token + "; httponly"));
        return responseBean;
    }

    @AttackVector(
            vulnerabilityExposed = VulnerabilitySubType.CLIENT_SIDE_VULNERABLE_JWT,
            description = "COOKIE_WITH_HTTPONLY_WITHOUT_SECURE_FLAG_BASED_JWT_VULNERABILITY")
    @AttackVector(
            vulnerabilityExposed = VulnerabilitySubType.SERVER_SIDE_VULNERABLE_JWT,
            description = "COOKIE_BASED_FOR_JWK_HEADER_BASED_JWT_VULNERABILITY")
    // https://nvd.nist.gov/vuln/detail/CVE-2018-0114
    @VulnerabilityLevel(
            value = LevelEnum.LEVEL_8,
            descriptionLabel = "COOKIE_CONTAINING_JWT_TOKEN",
            htmlTemplate = "LEVEL_2/JWT_Level2",
            parameterName = JWT,
            requestParameterLocation = RequestParameterLocation.COOKIE,
            sampleValues = {PRECOMPUTED_JWT_RS256_WITH_JWK})
    public ResponseBean<GenericVulnerabilityResponseBean<String>>
            getVulnerablePayloadLevelUnsecure8CookieBased(ParameterBean parameterBean)
                    throws UnsupportedEncodingException, ServiceApplicationException {
        JWTAlgorithmKMS jwtAlgorithmKMS = new JWTAlgorithmKMS();
        Optional<KeyPair> asymmetricAlgorithmKeyPair =
                jwtAlgorithmKMS.getAsymmetricAlgorithmKey("RS256");
        LOGGER.error(
                asymmetricAlgorithmKeyPair.isPresent() + " " + asymmetricAlgorithmKeyPair.get());
        List<String> tokens = parameterBean.getRequestHeadersMap().get("cookie");
        boolean isFetch = Boolean.valueOf(parameterBean.getQueryParamKeyValueMap().get("fetch"));
        if (!isFetch) {
            for (String token : tokens) {
                String[] cookieKeyValue = token.split(JWTUtils.BASE64_PADDING_CHARACTER_REGEX);
                if (cookieKeyValue[0].equals(JWT)) {
                    boolean isValid =
                            jwtValidator.jwkKeyHeaderPublicKeyTrustingVulnerableValidator(
                                    cookieKeyValue[1]);
                    ResponseBean<GenericVulnerabilityResponseBean<String>> responseBean =
                            this.getJWTResponseBean(isValid, token, !isValid);
                    responseBean
                            .getResponseHeaders()
                            .put("Set-Cookie", Arrays.asList(token + "; httponly"));
                    return responseBean;
                }
            }
        }

        JWK jwk =
                new RSAKey.Builder((RSAPublicKey) asymmetricAlgorithmKeyPair.get().getPublic())
                        .keyUse(KeyUse.SIGNATURE)
                        .keyID(UUID.randomUUID().toString())
                        .build();
        JSONObject header = new JSONObject();
        header.put(JWTUtils.JWT_ALGORITHM_KEY_HEADER, "RS256");
        header.put("typ", "JWT");
        header.put(JWTUtils.JSON_WEB_KEY_HEADER, new JSONObject(jwk.toJSONString()));

        String base64EncodedHeader =
                JWTUtils.getBase64UrlSafeWithoutPaddingEncodedString(header.toString());
        String token =
                libBasedJWTGenerator.getJWTToken_RS256(
                        base64EncodedHeader
                                + JWTUtils.JWT_TOKEN_PERIOD_CHARACTER
                                + GENERIC_BASE64_ENCODED_PAYLOAD,
                        asymmetricAlgorithmKeyPair.get().getPrivate());
        ResponseBean<GenericVulnerabilityResponseBean<String>> responseBean =
                this.getJWTResponseBean(true, token, true);
        responseBean
                .getResponseHeaders()
                .put("Set-Cookie", Arrays.asList(JWT_COOKIE_KEY + token + "; httponly"));
        return responseBean;
    }

    @AttackVector(
            vulnerabilityExposed = VulnerabilitySubType.CLIENT_SIDE_VULNERABLE_JWT,
            description = "COOKIE_WITH_HTTPONLY_WITHOUT_SECURE_FLAG_BASED_JWT_VULNERABILITY")
    @AttackVector(
            vulnerabilityExposed = VulnerabilitySubType.SERVER_SIDE_VULNERABLE_JWT,
            description = "COOKIE_BASED_EMPTY_TOKEN_JWT_VULNERABILITY")
    @VulnerabilityLevel(
            value = LevelEnum.LEVEL_9,
            descriptionLabel = "COOKIE_CONTAINING_JWT_TOKEN",
            htmlTemplate = "LEVEL_2/JWT_Level2",
            parameterName = JWT,
            requestParameterLocation = RequestParameterLocation.COOKIE,
            sampleValues = {PRECOMPUTED_JWT_HS256_HIGH_STRENGTH})
    public ResponseBean<GenericVulnerabilityResponseBean<String>>
            getVulnerablePayloadLevelUnsecure9CookieBased(ParameterBean parameterBean)
                    throws UnsupportedEncodingException, ServiceApplicationException {
        JWTAlgorithmKMS jwtAlgorithmKMS = new JWTAlgorithmKMS();
        Optional<SymmetricAlgorithmKey> symmetricAlgorithmKey =
                jwtAlgorithmKMS.getSymmetricAlgorithmKey(
                        JWTUtils.JWT_HMAC_SHA_256_ALGORITHM, KeyStrength.HIGH);
        LOGGER.error(symmetricAlgorithmKey.isPresent() + " " + symmetricAlgorithmKey.get());
        List<String> tokens = parameterBean.getRequestHeadersMap().get("cookie");
        boolean isFetch = Boolean.valueOf(parameterBean.getQueryParamKeyValueMap().get("fetch"));
        if (!isFetch) {
            for (String token : tokens) {
                String[] cookieKeyValue = token.split(JWTUtils.BASE64_PADDING_CHARACTER_REGEX);
                if (cookieKeyValue[0].equals(JWT)) {
                    boolean isValid =
                            jwtValidator.customHMACEmptyTokenVulnerableValidator(
                                    cookieKeyValue[1],
                                    symmetricAlgorithmKey.get().getKey(),
                                    JWTUtils.JWT_HMAC_SHA_256_ALGORITHM);
                    ResponseBean<GenericVulnerabilityResponseBean<String>> responseBean =
                            this.getJWTResponseBean(isValid, token, !isValid);
                    responseBean
                            .getResponseHeaders()
                            .put("Set-Cookie", Arrays.asList(token + "; httponly"));
                    return responseBean;
                }
            }
        }

        String token =
                libBasedJWTGenerator.getHMACSignedJWTToken(
                        JWTUtils.HS256_TOKEN_TO_BE_SIGNED,
                        JWTUtils.getBytes(symmetricAlgorithmKey.get().getKey()),
                        JWTUtils.JWT_HMAC_SHA_256_ALGORITHM);
        ResponseBean<GenericVulnerabilityResponseBean<String>> responseBean =
                this.getJWTResponseBean(true, token, true);
        responseBean
                .getResponseHeaders()
                .put("Set-Cookie", Arrays.asList(JWT_COOKIE_KEY + token + "; httponly"));
        return responseBean;
    }

    // Commented for now because this is not fully developed
    // @AttackVector(
    // vulnerabilityExposed = {VulnerabilitySubType.CLIENT_SIDE_VULNERABLE_JWT},
    // description =
    // "COOKIE_WITH_HTTPONLY_WITHOUT_SECURE_FLAG_BASED_JWT_VULNERABILITY")
    // @AttackVector(
    // vulnerabilityExposed = {VulnerabilitySubType.INSECURE_CONFIGURATION_JWT,
    // VulnerabilitySubType.BLIND_SQL_INJECTION},
    // description = "COOKIE_BASED_EMPTY_TOKEN_JWT_VULNERABILITY")
    // @VulnerabilityLevel(
    // value = LevelEnum.LEVEL_10,
    // descriptionLabel = "COOKIE_CONTAINING_JWT_TOKEN",
    // htmlTemplate = "LEVEL_2/JWT_Level2",
    // parameterName = JWT,
    // requestParameterLocation = RequestParameterLocation.COOKIE,
    // sampleValues = {""})
    public ResponseBean<GenericVulnerabilityResponseBean<String>>
            getVulnerablePayloadLevelUnsecure10CookieBased(ParameterBean parameterBean)
                    throws UnsupportedEncodingException, ServiceApplicationException {
        List<String> tokens = parameterBean.getRequestHeadersMap().get("cookie");
        boolean isFetch = Boolean.valueOf(parameterBean.getQueryParamKeyValueMap().get("fetch"));
        if (!isFetch) {
            for (String token : tokens) {
                String[] cookieKeyValue = token.split(JWTUtils.BASE64_PADDING_CHARACTER_REGEX);
                if (cookieKeyValue[0].equals(JWT)) {
                    RSAPublicKey rsaPublicKey =
                            JWTUtils.getRSAPublicKeyFromProvidedPEMFilePath(
                                    this.getClass()
                                            .getClassLoader()
                                            .getResourceAsStream(
                                                    JWTUtils.KEYS_LOCATION + "public_key.pem"));
                    boolean isValid =
                            this.jwtValidator.genericJWTTokenValidator(
                                    cookieKeyValue[1], rsaPublicKey, "RS256");
                    ResponseBean<GenericVulnerabilityResponseBean<String>> responseBean =
                            this.getJWTResponseBean(isValid, token, !isValid);
                    responseBean
                            .getResponseHeaders()
                            .put("Set-Cookie", Arrays.asList(token + "; httponly"));
                    return responseBean;
                }
            }
        }
        RSAPrivateKey rsaPrivateKey =
                JWTUtils.getRSAPrivateKeyFromProvidedPEMFilePath(
                        this.getClass()
                                .getClassLoader()
                                .getResourceAsStream(JWTUtils.KEYS_LOCATION + "private_key.pem"));
        String token =
                libBasedJWTGenerator.getJWTToken_RS256(
                        JWTUtils.RS256_TOKEN_TO_BE_SIGNED, rsaPrivateKey);
        ResponseBean<GenericVulnerabilityResponseBean<String>> responseBean =
                this.getJWTResponseBean(true, token, true);
        responseBean
                .getResponseHeaders()
                .put("Set-Cookie", Arrays.asList(JWT_COOKIE_KEY + token + "; httponly"));
        return responseBean;
    }
}
