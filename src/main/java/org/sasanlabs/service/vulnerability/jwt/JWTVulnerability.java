package org.sasanlabs.service.vulnerability.jwt;

import static org.sasanlabs.service.vulnerability.jwt.bean.JWTUtils.GENERIC_BASE64_ENCODED_PAYLOAD;

import com.nimbusds.jose.jwk.JWK;
import com.nimbusds.jose.jwk.KeyUse;
import com.nimbusds.jose.jwk.RSAKey;
import java.io.UnsupportedEncodingException;
import java.security.KeyPair;
import java.security.interfaces.RSAPrivateKey;
import java.security.interfaces.RSAPublicKey;
import java.util.Arrays;
import java.util.List;
import java.util.Optional;
import java.util.UUID;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.json.JSONObject;
import org.sasanlabs.internal.utility.LevelEnum;
import org.sasanlabs.internal.utility.annotations.AttackVector;
import org.sasanlabs.internal.utility.annotations.RequestParameterLocation;
import org.sasanlabs.internal.utility.annotations.VulnerabilityLevel;
import org.sasanlabs.internal.utility.annotations.VulnerableServiceRestEndPoint;
import org.sasanlabs.service.bean.ResponseBean;
import org.sasanlabs.service.exception.ServiceApplicationException;
import org.sasanlabs.service.vulnerability.ICustomVulnerableEndPoint;
import org.sasanlabs.service.vulnerability.ParameterBean;
import org.sasanlabs.service.vulnerability.jwt.bean.JWTResponseBean;
import org.sasanlabs.service.vulnerability.jwt.bean.JWTUtils;
import org.sasanlabs.service.vulnerability.jwt.keys.JWTAlgorithmKMS;
import org.sasanlabs.service.vulnerability.jwt.keys.KeyStrength;
import org.sasanlabs.service.vulnerability.jwt.keys.SymmetricAlgorithmKey;
import org.sasanlabs.vulnerability.types.VulnerabilitySubType;
import org.sasanlabs.vulnerability.types.VulnerabilityType;
import org.springframework.beans.factory.annotation.Autowired;

/**
 * JWT client and server side implementation issues and remediations. Server side issues like: 1.
 * Weak HMAC key 2. none algorithm attack 3. Weak Hash algorithm 4. tweak Algorithm and Key.
 *
 * <p>Client side issues like: 1. Storing jwt in local storage/session storage hence if attacked
 * with XSS can be quite dangerous. 2. Storing jwt in cookies without httponly/secure flags or
 * cookie prefixes.
 *
 * <p>{@link https://github.com/SasanLabs/JWTExtension/blob/master/BrainStorming.md}
 *
 * @author KSASAN preetkaran20@gmail.com
 */
@VulnerableServiceRestEndPoint(
        descriptionLabel = "JWT_INJECTION_VULNERABILITY",
        value = "JWTVulnerability",
        type = {VulnerabilityType.VULNERABLE_JWT_IMPLMENTATION})
public class JWTVulnerability implements ICustomVulnerableEndPoint {

    @Autowired private IJWTTokenGenerator libBasedJWTGenerator;

    @Autowired private IJWTValidator jwtValidator;

    private static final transient Logger LOGGER = LogManager.getLogger(JWTVulnerability.class);

    private static final String JWT = "JWT";

    private ResponseBean<JWTResponseBean> getJWTResponseBean(
            boolean isValid, String jwtToken, boolean includeToken) {
        JWTResponseBean jwtResponseBean = new JWTResponseBean();
        jwtResponseBean.setIsValid(isValid);
        if (includeToken) {
            jwtResponseBean.setJwtToken(jwtToken);
        }
        if (!isValid) {
            ResponseBean<JWTResponseBean> responseBean =
                    new ResponseBean<JWTResponseBean>(jwtResponseBean);
            responseBean.setHttpStatusCode(401);
            return responseBean;
        }
        return new ResponseBean<JWTResponseBean>(jwtResponseBean);
    }

    @AttackVector(
            vulnerabilityExposed = VulnerabilitySubType.CLIENT_SIDE_VULNERABLE_JWT,
            description = "JWT_URL_EXPOSING_SECURE_INFORMATION")
    @VulnerabilityLevel(
            value = LevelEnum.LEVEL_1,
            descriptionLabel = "URL_CONTAINING_JWT_TOKEN",
            htmlTemplate = "LEVEL_1/JWT_Level1",
            parameterName = JWT,
            sampleValues = {""})
    public ResponseBean<JWTResponseBean> getVulnerablePayloadLevelUnsecure(
            ParameterBean parameterBean)
            throws UnsupportedEncodingException, ServiceApplicationException {
        JWTAlgorithmKMS jwtAlgorithmKMS = new JWTAlgorithmKMS();
        Optional<SymmetricAlgorithmKey> symmetricAlgorithmKey =
                jwtAlgorithmKMS.getSymmetricAlgorithmKey(
                        JWTUtils.JWT_HMAC_SHA_256_ALGORITHM, KeyStrength.HIGH);
        LOGGER.error(symmetricAlgorithmKey.isPresent() + " " + symmetricAlgorithmKey.get());
        String token = parameterBean.getQueryParamKeyValueMap().get(JWT);
        if (token != null) {
            boolean isValid =
                    jwtValidator.customHMACValidator(
                            token,
                            JWTUtils.getBytes(symmetricAlgorithmKey.get().getKey()),
                            JWTUtils.JWT_HMAC_SHA_256_ALGORITHM);
            return this.getJWTResponseBean(isValid, token, !isValid);
        } else {
            token =
                    libBasedJWTGenerator.getHMACSignedJWTToken(
                            JWTUtils.HS256_TOKEN_TO_BE_SIGNED,
                            JWTUtils.getBytes(symmetricAlgorithmKey.get().getKey()),
                            JWTUtils.JWT_HMAC_SHA_256_ALGORITHM);
            return this.getJWTResponseBean(true, token, true);
        }
    }

    @AttackVector(
            vulnerabilityExposed = VulnerabilitySubType.CLIENT_SIDE_VULNERABLE_JWT,
            description = "COOKIE_CONTAINING_JWT_TOKEN_SECURITY_ATTRIBUTES_MISSING")
    @VulnerabilityLevel(
            value = LevelEnum.LEVEL_2,
            descriptionLabel = "COOKIE_CONTAINING_JWT_TOKEN",
            htmlTemplate = "LEVEL_2/JWT_Level2",
            parameterName = JWT,
            requestParameterLocation = RequestParameterLocation.COOKIE,
            sampleValues = {""})
    public ResponseBean<JWTResponseBean> getVulnerablePayloadLevelUnsecure2CookieBased(
            ParameterBean parameterBean)
            throws UnsupportedEncodingException, ServiceApplicationException {
        JWTAlgorithmKMS jwtAlgorithmKMS = new JWTAlgorithmKMS();
        Optional<SymmetricAlgorithmKey> symmetricAlgorithmKey =
                jwtAlgorithmKMS.getSymmetricAlgorithmKey(
                        JWTUtils.JWT_HMAC_SHA_256_ALGORITHM, KeyStrength.HIGH);
        LOGGER.error(symmetricAlgorithmKey.isPresent() + " " + symmetricAlgorithmKey.get());
        List<String> tokens = parameterBean.getRequestHeadersMap().get("cookie");
        boolean isFetch = Boolean.valueOf(parameterBean.getQueryParamKeyValueMap().get("fetch"));
        if (!isFetch) {
            for (String token : tokens) {
                String[] cookieKeyValue = token.split(JWTUtils.BASE64_PADDING_CHARACTER_REGEX);
                if (cookieKeyValue[0].equals(JWT)) {
                    boolean isValid =
                            jwtValidator.customHMACValidator(
                                    cookieKeyValue[1],
                                    JWTUtils.getBytes(symmetricAlgorithmKey.get().getKey()),
                                    JWTUtils.JWT_HMAC_SHA_256_ALGORITHM);
                    ResponseBean<JWTResponseBean> responseBean =
                            this.getJWTResponseBean(isValid, token, !isValid);
                    responseBean.getResponseHeaders().put("Set-Cookie", Arrays.asList(token));
                    return responseBean;
                }
            }
        }
        String token =
                libBasedJWTGenerator.getHMACSignedJWTToken(
                        JWTUtils.HS256_TOKEN_TO_BE_SIGNED,
                        JWTUtils.getBytes(symmetricAlgorithmKey.get().getKey()),
                        JWTUtils.JWT_HMAC_SHA_256_ALGORITHM);
        ResponseBean<JWTResponseBean> responseBean = this.getJWTResponseBean(true, token, true);
        responseBean.getResponseHeaders().put("Set-Cookie", Arrays.asList("JWTToken=" + token));
        return responseBean;
    }

    @AttackVector(
            vulnerabilityExposed = VulnerabilitySubType.CLIENT_SIDE_VULNERABLE_JWT,
            description = "COOKIE_WITH_HTTPONLY_WITHOUT_SECURE_FLAG_BASED_JWT_VULNERABILITY")
    @VulnerabilityLevel(
            value = LevelEnum.LEVEL_3,
            descriptionLabel = "COOKIE_CONTAINING_JWT_TOKEN",
            htmlTemplate = "LEVEL_2/JWT_Level2",
            parameterName = JWT,
            requestParameterLocation = RequestParameterLocation.COOKIE,
            sampleValues = {""})
    public ResponseBean<JWTResponseBean> getVulnerablePayloadLevelUnsecure3CookieBased(
            ParameterBean parameterBean)
            throws UnsupportedEncodingException, ServiceApplicationException {
        JWTAlgorithmKMS jwtAlgorithmKMS = new JWTAlgorithmKMS();
        Optional<SymmetricAlgorithmKey> symmetricAlgorithmKey =
                jwtAlgorithmKMS.getSymmetricAlgorithmKey(
                        JWTUtils.JWT_HMAC_SHA_256_ALGORITHM, KeyStrength.HIGH);
        LOGGER.error(symmetricAlgorithmKey.isPresent() + " " + symmetricAlgorithmKey.get());
        List<String> tokens = parameterBean.getRequestHeadersMap().get("cookie");
        boolean isFetch = Boolean.valueOf(parameterBean.getQueryParamKeyValueMap().get("fetch"));
        if (!isFetch) {
            for (String token : tokens) {
                String[] cookieKeyValue = token.split(JWTUtils.BASE64_PADDING_CHARACTER_REGEX);
                if (cookieKeyValue[0].equals(JWT)) {
                    boolean isValid =
                            jwtValidator.customHMACValidator(
                                    cookieKeyValue[1],
                                    JWTUtils.getBytes(symmetricAlgorithmKey.get().getKey()),
                                    JWTUtils.JWT_HMAC_SHA_256_ALGORITHM);
                    ResponseBean<JWTResponseBean> responseBean =
                            this.getJWTResponseBean(isValid, token, !isValid);
                    responseBean
                            .getResponseHeaders()
                            .put("Set-Cookie", Arrays.asList(token + "; httponly"));
                    return responseBean;
                }
            }
        }
        String token =
                libBasedJWTGenerator.getHMACSignedJWTToken(
                        JWTUtils.HS256_TOKEN_TO_BE_SIGNED,
                        JWTUtils.getBytes(symmetricAlgorithmKey.get().getKey()),
                        JWTUtils.JWT_HMAC_SHA_256_ALGORITHM);
        ResponseBean<JWTResponseBean> responseBean = this.getJWTResponseBean(true, token, true);
        responseBean
                .getResponseHeaders()
                .put("Set-Cookie", Arrays.asList("JWTToken=" + token + "; httponly"));
        return responseBean;
    }

    @AttackVector(
            vulnerabilityExposed = VulnerabilitySubType.CLIENT_SIDE_VULNERABLE_JWT,
            description = "COOKIE_WITH_HTTPONLY_WITHOUT_SECURE_FLAG_BASED_JWT_VULNERABILITY")
    @AttackVector(
            vulnerabilityExposed = VulnerabilitySubType.INSECURE_CONFIGURATION_JWT,
            description = "COOKIE_BASED_LOW_KEY_STRENGTH_JWT_VULNERABILITY")
    @VulnerabilityLevel(
            value = LevelEnum.LEVEL_4,
            descriptionLabel = "COOKIE_CONTAINING_JWT_TOKEN",
            htmlTemplate = "LEVEL_2/JWT_Level2",
            parameterName = JWT,
            requestParameterLocation = RequestParameterLocation.COOKIE,
            sampleValues = {""})
    public ResponseBean<JWTResponseBean> getVulnerablePayloadLevelUnsecure4CookieBased(
            ParameterBean parameterBean)
            throws UnsupportedEncodingException, ServiceApplicationException {
        JWTAlgorithmKMS jwtAlgorithmKMS = new JWTAlgorithmKMS();
        Optional<SymmetricAlgorithmKey> symmetricAlgorithmKey =
                jwtAlgorithmKMS.getSymmetricAlgorithmKey(
                        JWTUtils.JWT_HMAC_SHA_256_ALGORITHM, KeyStrength.LOW);
        LOGGER.error(symmetricAlgorithmKey.isPresent() + " " + symmetricAlgorithmKey.get());
        List<String> tokens = parameterBean.getRequestHeadersMap().get("cookie");
        boolean isFetch = Boolean.valueOf(parameterBean.getQueryParamKeyValueMap().get("fetch"));
        if (!isFetch) {
            for (String token : tokens) {
                String[] cookieKeyValue = token.split(JWTUtils.BASE64_PADDING_CHARACTER_REGEX);
                if (cookieKeyValue[0].equals(JWT)) {
                    boolean isValid =
                            jwtValidator.customHMACValidator(
                                    cookieKeyValue[1],
                                    JWTUtils.getBytes(symmetricAlgorithmKey.get().getKey()),
                                    JWTUtils.JWT_HMAC_SHA_256_ALGORITHM);
                    ResponseBean<JWTResponseBean> responseBean =
                            this.getJWTResponseBean(isValid, token, !isValid);
                    responseBean
                            .getResponseHeaders()
                            .put("Set-Cookie", Arrays.asList(token + "; httponly"));
                    return responseBean;
                }
            }
        }

        String token =
                libBasedJWTGenerator.getHMACSignedJWTToken(
                        JWTUtils.HS256_TOKEN_TO_BE_SIGNED,
                        JWTUtils.getBytes(symmetricAlgorithmKey.get().getKey()),
                        JWTUtils.JWT_HMAC_SHA_256_ALGORITHM);
        ResponseBean<JWTResponseBean> responseBean = this.getJWTResponseBean(true, token, true);
        responseBean
                .getResponseHeaders()
                .put("Set-Cookie", Arrays.asList("JWTToken=" + token + "; httponly"));
        return responseBean;
    }

    @AttackVector(
            vulnerabilityExposed = VulnerabilitySubType.CLIENT_SIDE_VULNERABLE_JWT,
            description = "COOKIE_WITH_HTTPONLY_WITHOUT_SECURE_FLAG_BASED_JWT_VULNERABILITY")
    @AttackVector(
            vulnerabilityExposed = {
                VulnerabilitySubType.SERVER_SIDE_VULNERABLE_JWT,
                VulnerabilitySubType.NULL_BYTE
            },
            description = "COOKIE_BASED_NULL_BYTE_JWT_VULNERABILITY")
    @VulnerabilityLevel(
            value = LevelEnum.LEVEL_5,
            descriptionLabel = "COOKIE_CONTAINING_JWT_TOKEN",
            htmlTemplate = "LEVEL_2/JWT_Level2",
            parameterName = JWT,
            requestParameterLocation = RequestParameterLocation.COOKIE,
            sampleValues = {""})
    public ResponseBean<JWTResponseBean> getVulnerablePayloadLevelUnsecure5CookieBased(
            ParameterBean parameterBean)
            throws UnsupportedEncodingException, ServiceApplicationException {
        JWTAlgorithmKMS jwtAlgorithmKMS = new JWTAlgorithmKMS();
        Optional<SymmetricAlgorithmKey> symmetricAlgorithmKey =
                jwtAlgorithmKMS.getSymmetricAlgorithmKey(
                        JWTUtils.JWT_HMAC_SHA_256_ALGORITHM, KeyStrength.HIGH);
        LOGGER.error(symmetricAlgorithmKey.isPresent() + " " + symmetricAlgorithmKey.get());
        List<String> tokens = parameterBean.getRequestHeadersMap().get("cookie");
        boolean isFetch = Boolean.valueOf(parameterBean.getQueryParamKeyValueMap().get("fetch"));
        if (!isFetch) {
            for (String token : tokens) {
                String[] cookieKeyValue = token.split(JWTUtils.BASE64_PADDING_CHARACTER_REGEX);
                if (cookieKeyValue[0].equals(JWT)) {
                    boolean isValid =
                            jwtValidator.customHMACNullByteVulnerableValidator(
                                    cookieKeyValue[1],
                                    JWTUtils.getBytes(symmetricAlgorithmKey.get().getKey()),
                                    JWTUtils.JWT_HMAC_SHA_256_ALGORITHM);
                    ResponseBean<JWTResponseBean> responseBean =
                            this.getJWTResponseBean(isValid, token, !isValid);
                    responseBean
                            .getResponseHeaders()
                            .put("Set-Cookie", Arrays.asList(token + "; httponly"));
                    return responseBean;
                }
            }
        }

        String token =
                libBasedJWTGenerator.getHMACSignedJWTToken(
                        JWTUtils.HS256_TOKEN_TO_BE_SIGNED,
                        JWTUtils.getBytes(symmetricAlgorithmKey.get().getKey()),
                        JWTUtils.JWT_HMAC_SHA_256_ALGORITHM);
        ResponseBean<JWTResponseBean> responseBean = this.getJWTResponseBean(true, token, true);
        responseBean
                .getResponseHeaders()
                .put("Set-Cookie", Arrays.asList("JWTToken=" + token + "; httponly"));
        return responseBean;
    }

    @AttackVector(
            vulnerabilityExposed = VulnerabilitySubType.CLIENT_SIDE_VULNERABLE_JWT,
            description = "COOKIE_WITH_HTTPONLY_WITHOUT_SECURE_FLAG_BASED_JWT_VULNERABILITY")
    @AttackVector(
            vulnerabilityExposed = VulnerabilitySubType.SERVER_SIDE_VULNERABLE_JWT,
            description = "COOKIE_BASED_NONE_ALGORITHM_JWT_VULNERABILITY",
            curlPayload = "NONE_ALGORITHM_ATTACK_CURL_PAYLOAD")
    @VulnerabilityLevel(
            value = LevelEnum.LEVEL_6,
            descriptionLabel = "COOKIE_CONTAINING_JWT_TOKEN",
            htmlTemplate = "LEVEL_2/JWT_Level2",
            parameterName = JWT,
            requestParameterLocation = RequestParameterLocation.COOKIE,
            sampleValues = {""})
    public ResponseBean<JWTResponseBean> getVulnerablePayloadLevelUnsecure6CookieBased(
            ParameterBean parameterBean)
            throws UnsupportedEncodingException, ServiceApplicationException {
        JWTAlgorithmKMS jwtAlgorithmKMS = new JWTAlgorithmKMS();
        Optional<SymmetricAlgorithmKey> symmetricAlgorithmKey =
                jwtAlgorithmKMS.getSymmetricAlgorithmKey(
                        JWTUtils.JWT_HMAC_SHA_256_ALGORITHM, KeyStrength.HIGH);
        LOGGER.error(symmetricAlgorithmKey.isPresent() + " " + symmetricAlgorithmKey.get());
        List<String> tokens = parameterBean.getRequestHeadersMap().get("cookie");
        boolean isFetch = Boolean.valueOf(parameterBean.getQueryParamKeyValueMap().get("fetch"));
        if (!isFetch) {
            for (String token : tokens) {
                String[] cookieKeyValue = token.split(JWTUtils.BASE64_PADDING_CHARACTER_REGEX);
                if (cookieKeyValue[0].equals(JWT)) {
                    boolean isValid =
                            jwtValidator.customHMACNoneAlgorithmVulnerableValidator(
                                    cookieKeyValue[1],
                                    JWTUtils.getBytes(symmetricAlgorithmKey.get().getKey()),
                                    JWTUtils.JWT_HMAC_SHA_256_ALGORITHM);
                    ResponseBean<JWTResponseBean> responseBean =
                            this.getJWTResponseBean(isValid, token, !isValid);
                    responseBean
                            .getResponseHeaders()
                            .put("Set-Cookie", Arrays.asList(token + "; httponly"));
                    return responseBean;
                }
            }
        }

        String token =
                libBasedJWTGenerator.getHMACSignedJWTToken(
                        JWTUtils.HS256_TOKEN_TO_BE_SIGNED,
                        JWTUtils.getBytes(symmetricAlgorithmKey.get().getKey()),
                        JWTUtils.JWT_HMAC_SHA_256_ALGORITHM);
        ResponseBean<JWTResponseBean> responseBean = this.getJWTResponseBean(true, token, true);
        responseBean
                .getResponseHeaders()
                .put("Set-Cookie", Arrays.asList("JWTToken=" + token + "; httponly"));
        return responseBean;
    }

    @AttackVector(
            vulnerabilityExposed = VulnerabilitySubType.CLIENT_SIDE_VULNERABLE_JWT,
            description = "COOKIE_WITH_HTTPONLY_WITHOUT_SECURE_FLAG_BASED_JWT_VULNERABILITY")
    @AttackVector(
            vulnerabilityExposed = VulnerabilitySubType.SERVER_SIDE_VULNERABLE_JWT,
            description = "COOKIE_BASED_KEY_CONFUSION_JWT_VULNERABILITY")
    @VulnerabilityLevel(
            value = LevelEnum.LEVEL_7,
            descriptionLabel = "COOKIE_CONTAINING_JWT_TOKEN",
            htmlTemplate = "LEVEL_2/JWT_Level2",
            parameterName = JWT,
            requestParameterLocation = RequestParameterLocation.COOKIE,
            sampleValues = {""})
    public ResponseBean<JWTResponseBean> getVulnerablePayloadLevelUnsecure7CookieBased(
            ParameterBean parameterBean)
            throws UnsupportedEncodingException, ServiceApplicationException {
        JWTAlgorithmKMS jwtAlgorithmKMS = new JWTAlgorithmKMS();
        Optional<KeyPair> asymmetricAlgorithmKeyPair =
                jwtAlgorithmKMS.getAsymmetricAlgorithmKey("RS256");
        LOGGER.error(
                asymmetricAlgorithmKeyPair.isPresent() + " " + asymmetricAlgorithmKeyPair.get());
        List<String> tokens = parameterBean.getRequestHeadersMap().get("cookie");
        boolean isFetch = Boolean.valueOf(parameterBean.getQueryParamKeyValueMap().get("fetch"));
        if (!isFetch) {
            for (String token : tokens) {
                String[] cookieKeyValue = token.split(JWTUtils.BASE64_PADDING_CHARACTER_REGEX);
                if (cookieKeyValue[0].equals(JWT)) {
                    boolean isValid =
                            jwtValidator.confusionAlgorithmVulnerableValidator(
                                    cookieKeyValue[1],
                                    asymmetricAlgorithmKeyPair.get().getPublic());
                    ResponseBean<JWTResponseBean> responseBean =
                            this.getJWTResponseBean(isValid, token, !isValid);
                    responseBean
                            .getResponseHeaders()
                            .put("Set-Cookie", Arrays.asList(token + "; httponly"));
                    return responseBean;
                }
            }
        }

        String token =
                libBasedJWTGenerator.getJWTToken_RS256(
                        JWTUtils.RS256_TOKEN_TO_BE_SIGNED,
                        asymmetricAlgorithmKeyPair.get().getPrivate());
        ResponseBean<JWTResponseBean> responseBean = this.getJWTResponseBean(true, token, true);
        responseBean
                .getResponseHeaders()
                .put("Set-Cookie", Arrays.asList("JWTToken=" + token + "; httponly"));
        return responseBean;
    }

    @AttackVector(
            vulnerabilityExposed = VulnerabilitySubType.CLIENT_SIDE_VULNERABLE_JWT,
            description = "COOKIE_WITH_HTTPONLY_WITHOUT_SECURE_FLAG_BASED_JWT_VULNERABILITY")
    @AttackVector(
            vulnerabilityExposed = VulnerabilitySubType.SERVER_SIDE_VULNERABLE_JWT,
            description = "COOKIE_BASED_FOR_JWK_HEADER_BASED_JWT_VULNERABILITY")
    // https://nvd.nist.gov/vuln/detail/CVE-2018-0114
    @VulnerabilityLevel(
            value = LevelEnum.LEVEL_8,
            descriptionLabel = "COOKIE_CONTAINING_JWT_TOKEN",
            htmlTemplate = "LEVEL_2/JWT_Level2",
            parameterName = JWT,
            requestParameterLocation = RequestParameterLocation.COOKIE,
            sampleValues = {""})
    public ResponseBean<JWTResponseBean> getVulnerablePayloadLevelUnsecure8CookieBased(
            ParameterBean parameterBean)
            throws UnsupportedEncodingException, ServiceApplicationException {
        JWTAlgorithmKMS jwtAlgorithmKMS = new JWTAlgorithmKMS();
        Optional<KeyPair> asymmetricAlgorithmKeyPair =
                jwtAlgorithmKMS.getAsymmetricAlgorithmKey("RS256");
        LOGGER.error(
                asymmetricAlgorithmKeyPair.isPresent() + " " + asymmetricAlgorithmKeyPair.get());
        List<String> tokens = parameterBean.getRequestHeadersMap().get("cookie");
        boolean isFetch = Boolean.valueOf(parameterBean.getQueryParamKeyValueMap().get("fetch"));
        if (!isFetch) {
            for (String token : tokens) {
                String[] cookieKeyValue = token.split(JWTUtils.BASE64_PADDING_CHARACTER_REGEX);
                if (cookieKeyValue[0].equals(JWT)) {
                    boolean isValid =
                            jwtValidator.jwkKeyHeaderPublicKeyTrustingVulnerableValidator(
                                    cookieKeyValue[1]);
                    ResponseBean<JWTResponseBean> responseBean =
                            this.getJWTResponseBean(isValid, token, !isValid);
                    responseBean
                            .getResponseHeaders()
                            .put("Set-Cookie", Arrays.asList(token + "; httponly"));
                    return responseBean;
                }
            }
        }

        JWK jwk =
                new RSAKey.Builder((RSAPublicKey) asymmetricAlgorithmKeyPair.get().getPublic())
                        .privateKey((RSAPrivateKey) asymmetricAlgorithmKeyPair.get().getPrivate())
                        .keyUse(KeyUse.SIGNATURE)
                        .keyID(UUID.randomUUID().toString())
                        .build();
        JSONObject header = new JSONObject();
        header.put(JWTUtils.JWT_ALGORITHM_KEY_HEADER, "RS256");
        header.put("typ", "JWT");
        header.put(JWTUtils.JSON_WEB_KEY_HEADER, new JSONObject(jwk.toJSONString()));

        String base64EncodedHeader =
                JWTUtils.getBase64UrlSafeWithoutPaddingEncodedString(header.toString());
        String token =
                libBasedJWTGenerator.getJWTToken_RS256(
                        base64EncodedHeader
                                + JWTUtils.JWT_TOKEN_PERIOD_CHARACTER
                                + GENERIC_BASE64_ENCODED_PAYLOAD,
                        asymmetricAlgorithmKeyPair.get().getPrivate());
        ResponseBean<JWTResponseBean> responseBean = this.getJWTResponseBean(true, token, true);
        responseBean
                .getResponseHeaders()
                .put("Set-Cookie", Arrays.asList("JWTToken=" + token + "; httponly"));
        return responseBean;
    }

    @AttackVector(
            vulnerabilityExposed = VulnerabilitySubType.CLIENT_SIDE_VULNERABLE_JWT,
            description = "COOKIE_WITH_HTTPONLY_WITHOUT_SECURE_FLAG_BASED_JWT_VULNERABILITY")
    @AttackVector(
            vulnerabilityExposed = VulnerabilitySubType.SERVER_SIDE_VULNERABLE_JWT,
            description = "COOKIE_BASED_EMPTY_TOKEN_JWT_VULNERABILITY")
    @VulnerabilityLevel(
            value = LevelEnum.LEVEL_9,
            descriptionLabel = "COOKIE_CONTAINING_JWT_TOKEN",
            htmlTemplate = "LEVEL_2/JWT_Level2",
            parameterName = JWT,
            requestParameterLocation = RequestParameterLocation.COOKIE,
            sampleValues = {""})
    public ResponseBean<JWTResponseBean> getVulnerablePayloadLevelUnsecure9CookieBased(
            ParameterBean parameterBean)
            throws UnsupportedEncodingException, ServiceApplicationException {
        JWTAlgorithmKMS jwtAlgorithmKMS = new JWTAlgorithmKMS();
        Optional<SymmetricAlgorithmKey> symmetricAlgorithmKey =
                jwtAlgorithmKMS.getSymmetricAlgorithmKey(
                        JWTUtils.JWT_HMAC_SHA_256_ALGORITHM, KeyStrength.HIGH);
        LOGGER.error(symmetricAlgorithmKey.isPresent() + " " + symmetricAlgorithmKey.get());
        List<String> tokens = parameterBean.getRequestHeadersMap().get("cookie");
        boolean isFetch = Boolean.valueOf(parameterBean.getQueryParamKeyValueMap().get("fetch"));
        if (!isFetch) {
            for (String token : tokens) {
                String[] cookieKeyValue = token.split(JWTUtils.BASE64_PADDING_CHARACTER_REGEX);
                if (cookieKeyValue[0].equals(JWT)) {
                    boolean isValid =
                            jwtValidator.customHMACEmptyTokenVulnerableValidator(
                                    cookieKeyValue[1],
                                    symmetricAlgorithmKey.get().getKey(),
                                    JWTUtils.JWT_HMAC_SHA_256_ALGORITHM);
                    ResponseBean<JWTResponseBean> responseBean =
                            this.getJWTResponseBean(isValid, token, !isValid);
                    responseBean
                            .getResponseHeaders()
                            .put("Set-Cookie", Arrays.asList(token + "; httponly"));
                    return responseBean;
                }
            }
        }

        String token =
                libBasedJWTGenerator.getHMACSignedJWTToken(
                        JWTUtils.HS256_TOKEN_TO_BE_SIGNED,
                        JWTUtils.getBytes(symmetricAlgorithmKey.get().getKey()),
                        JWTUtils.JWT_HMAC_SHA_256_ALGORITHM);
        ResponseBean<JWTResponseBean> responseBean = this.getJWTResponseBean(true, token, true);
        responseBean
                .getResponseHeaders()
                .put("Set-Cookie", Arrays.asList("JWTToken=" + token + "; httponly"));
        return responseBean;
    }

    // Commented for now because this is not fully developed
    //    @AttackVector(
    //            vulnerabilityExposed = {VulnerabilitySubType.CLIENT_SIDE_VULNERABLE_JWT},
    //            description = "COOKIE_WITH_HTTPONLY_WITHOUT_SECURE_FLAG_BASED_JWT_VULNERABILITY")
    //    @AttackVector(
    //            vulnerabilityExposed = {VulnerabilitySubType.INSECURE_CONFIGURATION_JWT,
    // VulnerabilitySubType.BLIND_SQL_INJECTION},
    //            description = "COOKIE_BASED_EMPTY_TOKEN_JWT_VULNERABILITY")
    //    @VulnerabilityLevel(
    //            value = LevelEnum.LEVEL_10,
    //            descriptionLabel = "COOKIE_CONTAINING_JWT_TOKEN",
    //            htmlTemplate = "LEVEL_2/JWT_Level2",
    //            parameterName = JWT,
    //            requestParameterLocation = RequestParameterLocation.COOKIE,
    //            sampleValues = {""})
    public ResponseBean<JWTResponseBean> getVulnerablePayloadLevelUnsecure10CookieBased(
            ParameterBean parameterBean)
            throws UnsupportedEncodingException, ServiceApplicationException {
        List<String> tokens = parameterBean.getRequestHeadersMap().get("cookie");
        boolean isFetch = Boolean.valueOf(parameterBean.getQueryParamKeyValueMap().get("fetch"));
        if (!isFetch) {
            for (String token : tokens) {
                String[] cookieKeyValue = token.split(JWTUtils.BASE64_PADDING_CHARACTER_REGEX);
                if (cookieKeyValue[0].equals(JWT)) {
                    RSAPublicKey rsaPublicKey =
                            JWTUtils.getRSAPublicKeyFromProvidedPEMFilePath(
                                    this.getClass()
                                            .getClassLoader()
                                            .getResourceAsStream(
                                                    JWTUtils.KEYS_LOCATION + "public_key.pem"));
                    boolean isValid =
                            this.jwtValidator.genericJWTTokenValidator(
                                    cookieKeyValue[1], rsaPublicKey, "RS256");
                    ResponseBean<JWTResponseBean> responseBean =
                            this.getJWTResponseBean(isValid, token, !isValid);
                    responseBean
                            .getResponseHeaders()
                            .put("Set-Cookie", Arrays.asList(token + "; httponly"));
                    return responseBean;
                }
            }
        }
        RSAPrivateKey rsaPrivateKey =
                JWTUtils.getRSAPrivateKeyFromProvidedPEMFilePath(
                        this.getClass()
                                .getClassLoader()
                                .getResourceAsStream(JWTUtils.KEYS_LOCATION + "private_key.pem"));
        String token =
                libBasedJWTGenerator.getJWTToken_RS256(
                        JWTUtils.RS256_TOKEN_TO_BE_SIGNED, rsaPrivateKey);
        ResponseBean<JWTResponseBean> responseBean = this.getJWTResponseBean(true, token, true);
        responseBean
                .getResponseHeaders()
                .put("Set-Cookie", Arrays.asList("JWTToken=" + token + "; httponly"));
        return responseBean;
    }
}
