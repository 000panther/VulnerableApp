package org.sasanlabs.service.vulnerability.jwt;

import java.io.UnsupportedEncodingException;
import java.util.Arrays;
import java.util.List;
import java.util.Optional;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.sasanlabs.internal.utility.GenericUtils;
import org.sasanlabs.internal.utility.LevelEnum;
import org.sasanlabs.internal.utility.annotations.VulnerabilityLevel;
import org.sasanlabs.internal.utility.annotations.VulnerableServiceRestEndPoint;
import org.sasanlabs.service.bean.ResponseBean;
import org.sasanlabs.service.exception.ServiceApplicationException;
import org.sasanlabs.service.vulnerability.ICustomVulnerableEndPoint;
import org.sasanlabs.service.vulnerability.ParameterBean;
import org.sasanlabs.service.vulnerability.jwt.keys.KeyStrength;
import org.sasanlabs.service.vulnerability.jwt.keys.SymmetricAlgorithmKMS;
import org.sasanlabs.service.vulnerability.jwt.keys.SymmetricAlgorithmKey;
import org.sasanlabs.vulnerability.types.VulnerabilityType;
import org.springframework.beans.factory.annotation.Autowired;

/**
 * JWT client and server side implementation issues and remediations. 
 * Server side issues like: 
 * 1. Weak HMAC key 
 * 2. none algorithm attack 
 * 3. Weak Hash algorithm 
 * 4. tweak Algorithm and Key.
 * 
 * Client side issues like:
 * 1. Storing jwt in local storage/session storage hence if attacked with XSS can be quite dangerous.
 * 2. Storing jwt in cookies without httponly/secure flags or cookie prefixes.
 * 
 * {@link https://github.com/SasanLabs/JWTExtension/blob/master/BrainStorming.md}
 * 
 * @author KSASAN preetkaran20@gmail.com
 */

@VulnerableServiceRestEndPoint(descriptionLabel = "JWT_INJECTION_VULNERABILITY", value = "JWTVulnerability", type = {
		VulnerabilityType.JWT })
public class JWTVulnerability implements ICustomVulnerableEndPoint {

	private ParameterBean parameterBean;

	@Autowired
	private IJWTTokenGenerator libBasedJWTGenerator;

	@Autowired
	private IJWTValidator jwtValidator;

	private static final transient Logger LOGGER = LogManager.getLogger(JWTVulnerability.class);

	@Override
	public void setParameterBean(ParameterBean paramBean) {
		this.parameterBean = paramBean;
	}

	@VulnerabilityLevel(value = LevelEnum.LEVEL_1, descriptionLabel = "URL_BASED_JWT_VULNERABILITY")
	public ResponseBean getVulnerablePayloadLevelUnsecure()
			throws UnsupportedEncodingException, ServiceApplicationException {
		SymmetricAlgorithmKMS symmetricAlgorithmKMS = new SymmetricAlgorithmKMS();
		Optional<SymmetricAlgorithmKey> symmetricAlgorithmKey = symmetricAlgorithmKMS.getKey("HS256", KeyStrength.HIGH);
		LOGGER.error(symmetricAlgorithmKey.isPresent() + " " + symmetricAlgorithmKey.get());
		String token = this.parameterBean.getQueryParamKeyValueMap().get("JWTToken");
		if (token != null) {
			boolean isValid = jwtValidator.customValidator(token, KeyStrength.HIGH, "HS256");
			return new ResponseBean(GenericUtils.wrapPayloadInGenericVulnerableAppTemplate("" + isValid));
		} else {
			token = libBasedJWTGenerator.getJWTToken_HS256(JWTUtils.HMAC_TOKEN_TO_BE_SIGNED,
					JWTUtils.getBytes(symmetricAlgorithmKey.get().getKey()));
			return new ResponseBean(GenericUtils.wrapPayloadInGenericVulnerableAppTemplate(token));
		}
	}

	@VulnerabilityLevel(value = LevelEnum.LEVEL_2, descriptionLabel = "COOKIE_WITHOUT_HTTPONLY_BASED_JWT_VULNERABILITY")
	public ResponseBean getVulnerablePayloadLevelUnsecure2CookieBased()
			throws UnsupportedEncodingException, ServiceApplicationException {
		SymmetricAlgorithmKMS symmetricAlgorithmKMS = new SymmetricAlgorithmKMS();
		Optional<SymmetricAlgorithmKey> symmetricAlgorithmKey = symmetricAlgorithmKMS.getKey("HS256", KeyStrength.HIGH);
		LOGGER.error(symmetricAlgorithmKey.isPresent() + " " + symmetricAlgorithmKey.get());
		List<String> tokens = this.parameterBean.getRequestHeadersMap().get("cookie");
		if (tokens != null) {
			for(String token: tokens) {
				String[] cookieKeyValue = token.split(JWTUtils.BASE64_PADDING_CHARACTER_REGEX);
				if(cookieKeyValue[0].equals("JWTToken")) {
					boolean isValid = jwtValidator.customValidator(cookieKeyValue[1], KeyStrength.HIGH, "HS256");
					ResponseBean responseBean = new ResponseBean(GenericUtils.wrapPayloadInGenericVulnerableAppTemplate("" + isValid));
					responseBean.getResponseHeaders().put("Set-Cookie", Arrays.asList(token));
					return responseBean;
				}
			}
		} 
			
		String token = libBasedJWTGenerator.getJWTToken_HS256(JWTUtils.HMAC_TOKEN_TO_BE_SIGNED,
				JWTUtils.getBytes(symmetricAlgorithmKey.get().getKey()));
		ResponseBean responseBean = new ResponseBean(GenericUtils.wrapPayloadInGenericVulnerableAppTemplate(token));
		responseBean.getResponseHeaders().put("Set-Cookie", Arrays.asList("JWTToken=" + token));
		return responseBean;
		
	}

	@VulnerabilityLevel(value = LevelEnum.LEVEL_3, descriptionLabel = "COOKIE_WITH_HTTPONLY_WITHOUT_SECURE_FLAG_BASED_JWT_VULNERABILITY")
	public ResponseBean getVulnerablePayloadLevelUnsecure3CookieBased()
			throws UnsupportedEncodingException, ServiceApplicationException {
		SymmetricAlgorithmKMS symmetricAlgorithmKMS = new SymmetricAlgorithmKMS();
		Optional<SymmetricAlgorithmKey> symmetricAlgorithmKey = symmetricAlgorithmKMS.getKey("HS256", KeyStrength.HIGH);
		LOGGER.error(symmetricAlgorithmKey.isPresent() + " " + symmetricAlgorithmKey.get());
		List<String> tokens = this.parameterBean.getRequestHeadersMap().get("cookie");
		if (tokens != null) {
			for(String token: tokens) {
				String[] cookieKeyValue = token.split(JWTUtils.BASE64_PADDING_CHARACTER_REGEX);
				if(cookieKeyValue[0].equals("JWTToken")) {
					boolean isValid = jwtValidator.customValidator(cookieKeyValue[1], KeyStrength.HIGH, "HS256");
					ResponseBean responseBean = new ResponseBean(GenericUtils.wrapPayloadInGenericVulnerableAppTemplate("" + isValid));
					responseBean.getResponseHeaders().put("Set-Cookie", Arrays.asList(token + "; httponly"));
					return responseBean;
				}
			}
		} 
			
		String token = libBasedJWTGenerator.getJWTToken_HS256(JWTUtils.HMAC_TOKEN_TO_BE_SIGNED,
				JWTUtils.getBytes(symmetricAlgorithmKey.get().getKey()));
		ResponseBean responseBean = new ResponseBean(GenericUtils.wrapPayloadInGenericVulnerableAppTemplate(token));
		responseBean.getResponseHeaders().put("Set-Cookie", Arrays.asList("JWTToken=" + token + "; httponly"));
		return responseBean;
		
	}

	
	@VulnerabilityLevel(value = LevelEnum.LEVEL_4, descriptionLabel = "COOKIE_BASED_LOW_KEY_STRENGTH_JWT_VULNERABILITY")
	public ResponseBean getVulnerablePayloadLevelUnsecure4CookieBased()
			throws UnsupportedEncodingException, ServiceApplicationException {
		SymmetricAlgorithmKMS symmetricAlgorithmKMS = new SymmetricAlgorithmKMS();
		Optional<SymmetricAlgorithmKey> symmetricAlgorithmKey = symmetricAlgorithmKMS.getKey("HS256", KeyStrength.LOW);
		LOGGER.error(symmetricAlgorithmKey.isPresent() + " " + symmetricAlgorithmKey.get());
		List<String> tokens = this.parameterBean.getRequestHeadersMap().get("cookie");
		if (tokens != null) {
			for(String token: tokens) {
				String[] cookieKeyValue = token.split(JWTUtils.BASE64_PADDING_CHARACTER_REGEX);
				if(cookieKeyValue[0].equals("JWTToken")) {
					boolean isValid = jwtValidator.customValidator(cookieKeyValue[1], KeyStrength.LOW, "HS256");
					ResponseBean responseBean = new ResponseBean(GenericUtils.wrapPayloadInGenericVulnerableAppTemplate("" + isValid));
					responseBean.getResponseHeaders().put("Set-Cookie", Arrays.asList(token + "; httponly"));
					return responseBean;
				}
			}
		} 
			
		String token = libBasedJWTGenerator.getJWTToken_HS256(JWTUtils.HMAC_TOKEN_TO_BE_SIGNED,
				JWTUtils.getBytes(symmetricAlgorithmKey.get().getKey()));
		ResponseBean responseBean = new ResponseBean(GenericUtils.wrapPayloadInGenericVulnerableAppTemplate(token));
		responseBean.getResponseHeaders().put("Set-Cookie", Arrays.asList("JWTToken=" + token + "; httponly"));
		return responseBean;
	}
	
	@VulnerabilityLevel(value = LevelEnum.LEVEL_5, descriptionLabel = "COOKIE_BASED_NULL_BYTE_JWT_VULNERABILITY")
	public ResponseBean getVulnerablePayloadLevelUnsecure5CookieBased()
			throws UnsupportedEncodingException, ServiceApplicationException {
		SymmetricAlgorithmKMS symmetricAlgorithmKMS = new SymmetricAlgorithmKMS();
		Optional<SymmetricAlgorithmKey> symmetricAlgorithmKey = symmetricAlgorithmKMS.getKey("HS256", KeyStrength.HIGH);
		LOGGER.error(symmetricAlgorithmKey.isPresent() + " " + symmetricAlgorithmKey.get());
		List<String> tokens = this.parameterBean.getRequestHeadersMap().get("cookie");
		if (tokens != null) {
			for(String token: tokens) {
				String[] cookieKeyValue = token.split(JWTUtils.BASE64_PADDING_CHARACTER_REGEX);
				if(cookieKeyValue[0].equals("JWTToken")) {
					boolean isValid = jwtValidator.customNullByteVulnerableValidator(cookieKeyValue[1], KeyStrength.HIGH, "HS256");
					ResponseBean responseBean = new ResponseBean(GenericUtils.wrapPayloadInGenericVulnerableAppTemplate("" + isValid));
					responseBean.getResponseHeaders().put("Set-Cookie", Arrays.asList(token + "; httponly"));
					return responseBean;
				}
			}
		} 
			
		String token = libBasedJWTGenerator.getJWTToken_HS256(JWTUtils.HMAC_TOKEN_TO_BE_SIGNED,
				JWTUtils.getBytes(symmetricAlgorithmKey.get().getKey()));
		ResponseBean responseBean = new ResponseBean(GenericUtils.wrapPayloadInGenericVulnerableAppTemplate(token));
		responseBean.getResponseHeaders().put("Set-Cookie", Arrays.asList("JWTToken=" + token + "; httponly"));
		return responseBean;
	}
	
	@VulnerabilityLevel(value = LevelEnum.LEVEL_6, descriptionLabel = "COOKIE_BASED_NONE_ALGORITHM_JWT_VULNERABILITY")
	public ResponseBean getVulnerablePayloadLevelUnsecure6CookieBased()
			throws UnsupportedEncodingException, ServiceApplicationException {
		SymmetricAlgorithmKMS symmetricAlgorithmKMS = new SymmetricAlgorithmKMS();
		Optional<SymmetricAlgorithmKey> symmetricAlgorithmKey = symmetricAlgorithmKMS.getKey("HS256", KeyStrength.HIGH);
		LOGGER.error(symmetricAlgorithmKey.isPresent() + " " + symmetricAlgorithmKey.get());
		List<String> tokens = this.parameterBean.getRequestHeadersMap().get("cookie");
		if (tokens != null) {
			for(String token: tokens) {
				String[] cookieKeyValue = token.split(JWTUtils.BASE64_PADDING_CHARACTER_REGEX);
				if(cookieKeyValue[0].equals("JWTToken")) {
					boolean isValid = jwtValidator.customNoneAlgorithmVulnerableValidator(cookieKeyValue[1], KeyStrength.HIGH, "HS256");
					ResponseBean responseBean = new ResponseBean(GenericUtils.wrapPayloadInGenericVulnerableAppTemplate("" + isValid));
					responseBean.getResponseHeaders().put("Set-Cookie", Arrays.asList(token + "; httponly"));
					return responseBean;
				}
			}
		} 
			
		String token = libBasedJWTGenerator.getJWTToken_HS256(JWTUtils.HMAC_TOKEN_TO_BE_SIGNED,
				JWTUtils.getBytes(symmetricAlgorithmKey.get().getKey()));
		ResponseBean responseBean = new ResponseBean(GenericUtils.wrapPayloadInGenericVulnerableAppTemplate(token));
		responseBean.getResponseHeaders().put("Set-Cookie", Arrays.asList("JWTToken=" + token + "; httponly"));
		return responseBean;
	}
	
	
	@VulnerabilityLevel(value = LevelEnum.LEVEL_7, descriptionLabel = "URL_BASED_JWT_VULNERABILITY")
	public ResponseBean getVulnerablePayloadLevel5() throws UnsupportedEncodingException, ServiceApplicationException {
		SymmetricAlgorithmKMS symmetricAlgorithmKMS = new SymmetricAlgorithmKMS();
		Optional<SymmetricAlgorithmKey> symmetricAlgorithmKey = symmetricAlgorithmKMS.getKey("HS256", KeyStrength.LOW);
		LOGGER.error(symmetricAlgorithmKey.isPresent() + " " + symmetricAlgorithmKey.get());
		String token = this.parameterBean.getQueryParamKeyValueMap().get("JWTToken");
		if (token != null) {
			boolean isValid = jwtValidator.customValidator(token, KeyStrength.LOW, "HS256");
			return new ResponseBean(GenericUtils.wrapPayloadInGenericVulnerableAppTemplate("" + isValid));
		} else {
			token = libBasedJWTGenerator.getJWTToken_HS256("",
					JWTUtils.getBytes(symmetricAlgorithmKey.get().getKey()));
			return new ResponseBean(GenericUtils.wrapPayloadInGenericVulnerableAppTemplate(token));
		}
	}
}
