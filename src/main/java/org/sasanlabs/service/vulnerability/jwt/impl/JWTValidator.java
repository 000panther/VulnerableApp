package org.sasanlabs.service.vulnerability.jwt.impl;

import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.security.Key;
import java.security.interfaces.RSAPublicKey;
import java.text.ParseException;
import java.util.Base64;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.json.JSONException;
import org.json.JSONObject;
import org.sasanlabs.service.vulnerability.jwt.IJWTTokenGenerator;
import org.sasanlabs.service.vulnerability.jwt.IJWTValidator;
import org.sasanlabs.service.vulnerability.jwt.JWTUtils;
import org.sasanlabs.service.vulnerability.jwt.JWTVulnerability;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import com.nimbusds.jose.JOSEException;
import com.nimbusds.jose.JWSVerifier;
import com.nimbusds.jose.crypto.ECDSAVerifier;
import com.nimbusds.jose.crypto.Ed25519Verifier;
import com.nimbusds.jose.crypto.RSASSAVerifier;
import com.nimbusds.jose.jwk.ECKey;
import com.nimbusds.jose.jwk.OctetKeyPair;
import com.nimbusds.jose.jwk.RSAKey;
import com.nimbusds.jwt.SignedJWT;

/**
 * JWTValidator is used for validating jwt token. it will contain various
 * implementations of validating libraries.
 * 
 * @author KSASAN preetkaran20@gmail.com
 */
@Component
public class JWTValidator implements IJWTValidator {

	private static final transient Logger LOGGER = LogManager.getLogger(JWTVulnerability.class);

	@Autowired
	private IJWTTokenGenerator libBasedJWTGenerator;

	@Override
	public boolean customHS256Validator(String token, byte[] key) {
		try {
			String[] jwtParts = token.split(JWTUtils.JWT_TOKEN_PERIOD_CHARACTER_REGEX, -1);
			String newTokenSigned = libBasedJWTGenerator
					.getJWTToken_HS256(jwtParts[0] + JWTUtils.JWT_TOKEN_PERIOD_CHARACTER + jwtParts[1], key);
			if (newTokenSigned.equals(token)) {
				return true;
			} else {
				return false;
			}
		} catch (Exception ex) {
			LOGGER.error(ex);
			return false;
		}
	}

	@Override
	public boolean customHS256NullByteVulnerableValidator(String token, byte[] key) {
		try {
			String[] jwtParts = token.split(JWTUtils.JWT_TOKEN_PERIOD_CHARACTER_REGEX, -1);
			if (jwtParts.length < 3) {
				return false;
			}
			int nullByteIndex = jwtParts[2]
					.indexOf(URLEncoder.encode(String.valueOf((char) 0), StandardCharsets.UTF_8.name()));
			if (nullByteIndex > 0) {
				jwtParts[2] = jwtParts[2].substring(0, nullByteIndex);
			}
			return this.customHS256Validator(jwtParts[0] + JWTUtils.JWT_TOKEN_PERIOD_CHARACTER + jwtParts[1]
					+ JWTUtils.JWT_TOKEN_PERIOD_CHARACTER + jwtParts[2], key);
		} catch (Exception ex) {
			LOGGER.error(ex);
			return false;
		}
	}

	@Override
	public boolean customHS256NoneAlgorithmVulnerableValidator(String token, byte[] key) {
		try {
			String[] jwtParts = token.split(JWTUtils.JWT_TOKEN_PERIOD_CHARACTER_REGEX, -1);
			JSONObject header = new JSONObject(
					JWTUtils.getString(Base64.getUrlDecoder().decode(jwtParts[0].getBytes(StandardCharsets.UTF_8))));
			if (header.has(JWTUtils.JWT_ALGORITHM_KEY_HEADER)) {
				String alg = header.getString(JWTUtils.JWT_ALGORITHM_KEY_HEADER);
				if (JWTUtils.NONE_ALGORITHM.contentEquals(alg.toLowerCase())) {
					return true;
				}
			}
			return this.customHS256Validator(token, key);
		} catch (Exception ex) {
			LOGGER.error(ex);
			return false;
		}
	}

	@Override
	public boolean confusionAlgorithmVulnerableValidator(String token, Key key)
			throws JSONException, UnsupportedEncodingException {
		String[] jwtParts = token.split(JWTUtils.JWT_TOKEN_PERIOD_CHARACTER_REGEX, -1);
		JSONObject header = new JSONObject(
				JWTUtils.getString(Base64.getUrlDecoder().decode(jwtParts[0].getBytes(StandardCharsets.UTF_8))));
		if (header.has(JWTUtils.JWT_ALGORITHM_KEY_HEADER)) {
			String alg = header.getString(JWTUtils.JWT_ALGORITHM_KEY_HEADER);
			switch (alg) {
			case "HS256":
				return this.customHS256Validator(token, key.getEncoded());
			case "RS256":
				try {
					JWSVerifier verifier = new RSASSAVerifier((RSAPublicKey) key);
					SignedJWT signedJWT = SignedJWT.parse(token);
					return signedJWT.verify(verifier);
//					Jws<Claims> jws = Jwts.parser().setSigningKey(key).parseClaimsJws(token);
				} catch (ParseException | JOSEException ex) {
					LOGGER.error(ex);
					return false;
				}
				// return true;
			}
		}
		return false;
	}

	@Override
	public boolean jwkKeyHeaderPublicKeyTrustingVulnerableValidator(String token)
			throws JSONException, UnsupportedEncodingException {
		String[] jwtParts = token.split(JWTUtils.JWT_TOKEN_PERIOD_CHARACTER_REGEX, -1);
		JSONObject header = new JSONObject(
				JWTUtils.getString(Base64.getUrlDecoder().decode(jwtParts[0].getBytes(StandardCharsets.UTF_8))));
		if (header.has(JWTUtils.JWT_ALGORITHM_KEY_HEADER)) {
			String alg = header.getString(JWTUtils.JWT_ALGORITHM_KEY_HEADER);
			try {
				JWSVerifier verifier = null;
				if (header.has(JWTUtils.JSON_WEB_KEY_HEADER)) {
					//jwkSet = JWKSet.parse(header.getJSONObject(JWTUtils.JSON_WEB_KEY_HEADER).toString());
					if (alg.startsWith(JWTUtils.JWT_RSA_ALGORITHM_IDENTIFIER)
							|| alg.startsWith(JWTUtils.JWT_RSA_PSS_ALGORITHM_IDENTIFIER)) {
						RSAKey rsaKey = RSAKey.parse(header.getJSONObject(JWTUtils.JSON_WEB_KEY_HEADER).toString());
						verifier = new RSASSAVerifier(rsaKey.toRSAPublicKey());
					} else if (alg.startsWith(JWTUtils.JWT_EC_ALGORITHM_IDENTIFIER)) {
						ECKey ecKey = ECKey.parse(header.getJSONObject(JWTUtils.JSON_WEB_KEY_HEADER).toString());
						verifier = new ECDSAVerifier(ecKey.toECPublicKey());
					} else if (alg.startsWith(JWTUtils.JWT_OCTET_ALGORITHM_IDENTIFIER)) {
						verifier = new Ed25519Verifier(
								OctetKeyPair.parse(header.getString(JWTUtils.JSON_WEB_KEY_HEADER)));
					}
					// Jws<Claims> jws =
					// Jwts.parser().setSigningKey(header.getString(JWTUtils.JSON_WEB_KEY_HEADER))
					// .parseClaimsJws(token);
				}
				SignedJWT signedJWT = SignedJWT.parse(token);
				return signedJWT.verify(verifier);
			} catch (ParseException | JOSEException ex) {
				LOGGER.error(ex);
				return false;
			}
		}
		return false;
	}

}
