package org.sasanlabs.service.vulnerability.jwt.impl;

import java.nio.charset.StandardCharsets;
import java.util.Optional;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.sasanlabs.service.vulnerability.jwt.IJWTValidator;
import org.sasanlabs.service.vulnerability.jwt.ILibBasedJWTGenerator;
import org.sasanlabs.service.vulnerability.jwt.JWTServerSideVulnerability;
import org.sasanlabs.service.vulnerability.jwt.JWTUtils;
import org.sasanlabs.service.vulnerability.jwt.keys.JWTLibrary;
import org.sasanlabs.service.vulnerability.jwt.keys.KeyStrength;
import org.sasanlabs.service.vulnerability.jwt.keys.SymmetricAlgorithmKMS;
import org.sasanlabs.service.vulnerability.jwt.keys.SymmetricAlgorithmKey;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;

/**
 * JWTValidator is used for validating jwt token. it will contain various
 * implementations of validating libraries.
 * 
 * @author KSASAN preetkaran20@gmail.com
 */
@Component
public class JWTValidator implements IJWTValidator {

	private static final transient Logger LOGGER = LogManager.getLogger(JWTServerSideVulnerability.class);

	@Autowired
	private ILibBasedJWTGenerator libBasedJWTGenerator;

	@Override
	public boolean validateBasedOnJJWTLib(String token, JWTLibrary jwtLibrary, KeyStrength keyStrength,
			String algorithm) {
		try {
			SymmetricAlgorithmKMS symmetricAlgorithmKMS = new SymmetricAlgorithmKMS();
			Optional<SymmetricAlgorithmKey> symmetricAlgorithmKey = symmetricAlgorithmKMS.getKey(algorithm, keyStrength,
					jwtLibrary);
			LOGGER.error(symmetricAlgorithmKey.isPresent() + " " + symmetricAlgorithmKey.get());

			Claims claims = Jwts.parser().setSigningKey(symmetricAlgorithmKey.get().getKey()).parseClaimsJws(token)
					.getBody();
		} catch (Exception ex) {
			LOGGER.error(ex);
			return false;
		}
		return true;
	}

	@Override
	public boolean validateBasedOnCustomLib(String token, JWTLibrary jwtLibrary, KeyStrength keyStrength,
			String algorithm) {
		try {
			SymmetricAlgorithmKMS symmetricAlgorithmKMS = new SymmetricAlgorithmKMS();
			Optional<SymmetricAlgorithmKey> symmetricAlgorithmKey = symmetricAlgorithmKMS.getKey(algorithm, keyStrength,
					jwtLibrary);
			LOGGER.error(symmetricAlgorithmKey.isPresent() + " " + symmetricAlgorithmKey.get());
			String[] jwtParts = token.split(JWTUtils.JWT_TOKEN_PERIOD_CHARACTER_REGEX);
			String newTokenSigned = libBasedJWTGenerator.getJWTToken_Custom_HS256(
					jwtParts[0] + JWTUtils.JWT_TOKEN_PERIOD_CHARACTER + jwtParts[1],
					JWTUtils.getBytes(symmetricAlgorithmKey.get().getKey()));
			if(newTokenSigned.equals(token)) {
				return true;
			} else {
				return false;
			}
		} catch (Exception ex) {
			LOGGER.error(ex);
			return false;
		}
	}

	@Override
	public boolean validateBasedOnAuth0JWT(String key, String token) {
		// TODO Auto-generated method stub
		return false;
	}

	@Override
	public boolean validateBasedOnAuth0JWT(String key, String algorithm, String token) {
		// TODO Auto-generated method stub
		return false;
	}

}
