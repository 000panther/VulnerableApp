package org.sasanlabs.service.vulnerability.jwt.impl;

import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.security.Key;
import java.util.Base64;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.json.JSONException;
import org.json.JSONObject;
import org.sasanlabs.service.vulnerability.jwt.IJWTTokenGenerator;
import org.sasanlabs.service.vulnerability.jwt.IJWTValidator;
import org.sasanlabs.service.vulnerability.jwt.JWTUtils;
import org.sasanlabs.service.vulnerability.jwt.JWTVulnerability;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jws;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.security.SignatureException;

/**
 * JWTValidator is used for validating jwt token. it will contain various
 * implementations of validating libraries.
 * 
 * @author KSASAN preetkaran20@gmail.com
 */
@Component
public class JWTValidator implements IJWTValidator {

	private static final transient Logger LOGGER = LogManager.getLogger(JWTVulnerability.class);

	@Autowired
	private IJWTTokenGenerator libBasedJWTGenerator;

	@Override
	public boolean customHS256Validator(String token, byte[] key) {
		try {
			String[] jwtParts = token.split(JWTUtils.JWT_TOKEN_PERIOD_CHARACTER_REGEX);
			String newTokenSigned = libBasedJWTGenerator.getJWTToken_HS256(
					jwtParts[0] + JWTUtils.JWT_TOKEN_PERIOD_CHARACTER + jwtParts[1],
					key);
			if (newTokenSigned.equals(token)) {
				return true;
			} else {
				return false;
			}
		} catch (Exception ex) {
			LOGGER.error(ex);
			return false;
		}
	}

	@Override
	public boolean customHS256NullByteVulnerableValidator(String token, byte[] key) {
		try {
			String[] jwtParts = token.split(JWTUtils.JWT_TOKEN_PERIOD_CHARACTER_REGEX);
			if(jwtParts.length < 3) {
				return false;
			}
			int nullByteIndex = jwtParts[2].indexOf(URLEncoder.encode(String.valueOf((char) 0), StandardCharsets.UTF_8.name()));
			if(nullByteIndex > 0) {
				jwtParts[2] = jwtParts[2].substring(0, nullByteIndex);
			}
			return this.customHS256Validator(jwtParts[0] + JWTUtils.JWT_TOKEN_PERIOD_CHARACTER + jwtParts[1]
					+ JWTUtils.JWT_TOKEN_PERIOD_CHARACTER + jwtParts[2], key);
		} catch (Exception ex) {
			LOGGER.error(ex);
			return false;
		}
	}

	@Override
	public boolean customHS256NoneAlgorithmVulnerableValidator(String token, byte[] key) {
		try {
			String[] jwtParts = token.split(JWTUtils.JWT_TOKEN_PERIOD_CHARACTER_REGEX);
			JSONObject header = new JSONObject(
					JWTUtils.getString(Base64.getUrlDecoder().decode(jwtParts[0].getBytes(StandardCharsets.UTF_8))));
			if (header.has(JWTUtils.JWT_ALGORITHM_KEY_HEADER)) {
				String alg = header.getString(JWTUtils.JWT_ALGORITHM_KEY_HEADER);
				if (JWTUtils.NONE_ALGORITHM.contentEquals(alg.toLowerCase())) {
					return true;
				}
			}
			return this.customHS256Validator(token, key);
		} catch (Exception ex) {
			LOGGER.error(ex);
			return false;
		}
	}

	@Override
	public boolean confusionAlgorithmVulnarableValidator(String token, Key key) throws JSONException, UnsupportedEncodingException {
		String[] jwtParts = token.split(JWTUtils.JWT_TOKEN_PERIOD_CHARACTER_REGEX);
		JSONObject header = new JSONObject(
				JWTUtils.getString(Base64.getUrlDecoder().decode(jwtParts[0].getBytes(StandardCharsets.UTF_8))));
		if (header.has(JWTUtils.JWT_ALGORITHM_KEY_HEADER)) {
			String alg = header.getString(JWTUtils.JWT_ALGORITHM_KEY_HEADER);
			switch (alg) {
			case "HS256":
				return this.customHS256Validator(token, key.getEncoded());
			default:
				try {
				 Jws<Claims> jws = Jwts.parser()
				    .setSigningKey(key)
				    .parseClaimsJws(token);
				} catch(SignatureException ex) {
					LOGGER.error(ex);
					return false;
				}
				return true;
			}
		}
		return false;
	}

}
