package org.sasanlabs.service.vulnerability.jwt.impl;

import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.util.Arrays;
import java.util.Base64;
import java.util.Optional;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.json.JSONObject;
import org.sasanlabs.service.vulnerability.jwt.IJWTTokenGenerator;
import org.sasanlabs.service.vulnerability.jwt.IJWTValidator;
import org.sasanlabs.service.vulnerability.jwt.JWTUtils;
import org.sasanlabs.service.vulnerability.jwt.JWTVulnerability;
import org.sasanlabs.service.vulnerability.jwt.keys.KeyStrength;
import org.sasanlabs.service.vulnerability.jwt.keys.SymmetricAlgorithmKMS;
import org.sasanlabs.service.vulnerability.jwt.keys.SymmetricAlgorithmKey;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

/**
 * JWTValidator is used for validating jwt token. it will contain various
 * implementations of validating libraries.
 * 
 * @author KSASAN preetkaran20@gmail.com
 */
@Component
public class JWTValidator implements IJWTValidator {

	private static final transient Logger LOGGER = LogManager.getLogger(JWTVulnerability.class);

	@Autowired
	private IJWTTokenGenerator libBasedJWTGenerator;

	@Override
	public boolean customValidator(String token, KeyStrength keyStrength, String algorithm) {
		try {
			SymmetricAlgorithmKMS symmetricAlgorithmKMS = new SymmetricAlgorithmKMS();
			Optional<SymmetricAlgorithmKey> symmetricAlgorithmKey = symmetricAlgorithmKMS.getKey(algorithm,
					keyStrength);
			LOGGER.error(symmetricAlgorithmKey.isPresent() + " " + symmetricAlgorithmKey.get());
			String[] jwtParts = token.split(JWTUtils.JWT_TOKEN_PERIOD_CHARACTER_REGEX);
			String newTokenSigned = libBasedJWTGenerator.getJWTToken_HS256(
					jwtParts[0] + JWTUtils.JWT_TOKEN_PERIOD_CHARACTER + jwtParts[1],
					JWTUtils.getBytes(symmetricAlgorithmKey.get().getKey()));
			if (newTokenSigned.equals(token)) {
				return true;
			} else {
				return false;
			}
		} catch (Exception ex) {
			LOGGER.error(ex);
			return false;
		}
	}

	@Override
	public boolean customNullByteVulnerableValidator(String token, KeyStrength keyStrength, String algorithm) {
		try {
			String[] jwtParts = token.split(JWTUtils.JWT_TOKEN_PERIOD_CHARACTER_REGEX);
			if(jwtParts.length < 3) {
				return false;
			}
			int nullByteIndex = jwtParts[2].indexOf(URLEncoder.encode(String.valueOf((char) 0), StandardCharsets.UTF_8.name()));
			if(nullByteIndex > 0) {
				jwtParts[2] = jwtParts[2].substring(0, nullByteIndex);
			}
			return this.customValidator(jwtParts[0] + JWTUtils.JWT_TOKEN_PERIOD_CHARACTER + jwtParts[1]
					+ JWTUtils.JWT_TOKEN_PERIOD_CHARACTER + jwtParts[2], keyStrength, algorithm);
		} catch (Exception ex) {
			LOGGER.error(ex);
			return false;
		}
	}

	@Override
	public boolean customNoneAlgorithmVulnerableValidator(String token, KeyStrength keyStrength, String algorithm) {
		try {
			String[] jwtParts = token.split(JWTUtils.JWT_TOKEN_PERIOD_CHARACTER_REGEX);
			JSONObject header = new JSONObject(
					JWTUtils.getString(Base64.getUrlDecoder().decode(jwtParts[0].getBytes(StandardCharsets.UTF_8))));
			if (header.has(JWTUtils.JWT_ALGORITHM_KEY_HEADER)) {
				String alg = header.getString(JWTUtils.JWT_ALGORITHM_KEY_HEADER);
				if (JWTUtils.NONE_ALGORITHM.contentEquals(alg.toLowerCase())) {
					return true;
				}
			}
			return this.customValidator(token, keyStrength, algorithm);
		} catch (Exception ex) {
			LOGGER.error(ex);
			return false;
		}
	}

}
