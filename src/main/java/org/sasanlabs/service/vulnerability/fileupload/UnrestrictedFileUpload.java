package org.sasanlabs.service.vulnerability.fileupload;

import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.Date;
import java.util.Random;
import java.util.regex.Pattern;
import org.apache.commons.text.StringEscapeUtils;
import org.sasanlabs.internal.utility.FrameworkConstants;
import org.sasanlabs.internal.utility.LevelConstants;
import org.sasanlabs.internal.utility.annotations.AttackVector;
import org.sasanlabs.internal.utility.annotations.VulnerableAppRequestMapping;
import org.sasanlabs.internal.utility.annotations.VulnerableAppRestController;
import org.sasanlabs.service.exception.ServiceApplicationException;
import org.sasanlabs.service.vulnerability.bean.GenericVulnerabilityResponseBean;
import org.sasanlabs.vulnerability.types.VulnerabilitySubType;
import org.sasanlabs.vulnerability.types.VulnerabilityType;
import org.sasanlabs.vulnerability.utils.Constants;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.multipart.MultipartFile;

/**
 * @author KSASAN preetkaran20@gmail.com
 *     <p>Special Thanks
 *     <p>https://bezkoder.com/spring-boot-file-upload/
 *     <p>https://developer.mozilla.org/en-US/docs/Web/API/FormData/Using_FormData_Objects
 *     <p>https://www.youtube.com/watch?v=CmF9sEyKZNo
 *     <p>For content type checking we might need to use Apache Tika library or any such library.
 *     One important thing is as these libraries are really heavy and we are writing vulnerableApp
 *     so secure implementation might not be needed so ignoring addition of these libraries.
 */
@VulnerableAppRestController(
        descriptionLabel = "UNRESTRICTED_FILE_UPLOAD_VULNERABILITY",
        value = "UnrestrictedFileUpload",
        type = {VulnerabilityType.UNRESTRICTED_FILE_UPLOAD})
public class UnrestrictedFileUpload {
    private final Path root;

    private static final String STATIC_FILE_LOCATION = "upload";
    private static final String BASE_PATH = "static";
    private static final Random RANDOM = new Random(new Date().getTime());
    private static final Pattern ENDS_WITH_HTML_PATTERN = Pattern.compile("^.+\\.html$");
    private static final Pattern ENDS_WITH_HTML_OR_HTM_PATTERN =
            Pattern.compile("^.+\\.(html|htm)$");

    private static final String CONTAINS_PNG_JPEG_REGEX = "^.+\\.(png|jpeg)";
    private static final Pattern CONTAINS_PNG_OR_JPEG_PATTERN =
            Pattern.compile(CONTAINS_PNG_JPEG_REGEX);
    private static final Pattern ENDS_WITH_PNG_OR_JPEG_PATTERN =
            Pattern.compile(CONTAINS_PNG_JPEG_REGEX + "$");

    public UnrestrictedFileUpload() throws IOException, URISyntaxException {
        URI uploadDirectoryURI =
                new URI(
                        Thread.currentThread()
                                        .getContextClassLoader()
                                        .getResource(BASE_PATH)
                                        .toURI()
                                + FrameworkConstants.SLASH
                                + STATIC_FILE_LOCATION);
        root = Paths.get(uploadDirectoryURI);
        if (!root.toFile().exists()) {
            Files.createDirectory(root);
        }
    }

    // Has XSS <img src="" onerror=alert(1) /> file name reflected and stored is there.
    // this has both File Upload and Xss as per my handling.
    @AttackVector(
            vulnerabilityExposed = {
                VulnerabilitySubType.UNRESTRICTED_FILE_UPLOAD,
                VulnerabilitySubType.PERSISTENT_XSS,
                VulnerabilitySubType.REFLECTED_XSS,
                VulnerabilitySubType.PATH_TRAVERSAL
            },
            description = "UNRESTRICTED_FILE_UPLOAD_NO_VALIDATION_FILE_NAME")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_1,
            descriptionLabel = "URL_CONTAINING_JWT_TOKEN",
            htmlTemplate = "LEVEL_1/FileUpload",
            parameterName = "",
            sampleValues = "",
            requestMethod = RequestMethod.POST)
    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel1(
            @RequestParam("file") MultipartFile file)
            throws ServiceApplicationException, IOException, URISyntaxException {
        String fileName = file.getOriginalFilename();
        Files.copy(
                file.getInputStream(), root.resolve(fileName), StandardCopyOption.REPLACE_EXISTING);
        return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(
                new GenericVulnerabilityResponseBean<String>(
                        STATIC_FILE_LOCATION + FrameworkConstants.SLASH + fileName, true),
                HttpStatus.OK);
    }

    // Has XSS <img src="" onerror=alert(1) /> file name reflected and stored is there.
    @AttackVector(
            vulnerabilityExposed = {
                VulnerabilitySubType.UNRESTRICTED_FILE_UPLOAD,
                VulnerabilitySubType.PERSISTENT_XSS,
                VulnerabilitySubType.REFLECTED_XSS
            },
            description = "UNRESTRICTED_FILE_UPLOAD_NO_VALIDATION_FILE_NAME")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_2,
            descriptionLabel = "URL_CONTAINING_JWT_TOKEN",
            htmlTemplate = "LEVEL_1/FileUpload",
            parameterName = "",
            sampleValues = "",
            requestMethod = RequestMethod.POST)
    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel2(
            @RequestParam("file") MultipartFile file)
            throws ServiceApplicationException, IOException {
        String fileName = RANDOM.nextInt() + "_" + file.getOriginalFilename();
        Files.copy(
                file.getInputStream(), root.resolve(fileName), StandardCopyOption.REPLACE_EXISTING);
        return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(
                new GenericVulnerabilityResponseBean<String>(
                        STATIC_FILE_LOCATION + FrameworkConstants.SLASH + fileName, true),
                HttpStatus.OK);
    }

    // a .htm extension breaks the file upload vulnerability
    @AttackVector(
            vulnerabilityExposed = {
                VulnerabilitySubType.UNRESTRICTED_FILE_UPLOAD,
                VulnerabilitySubType.PERSISTENT_XSS,
                VulnerabilitySubType.REFLECTED_XSS
            },
            description = "UNRESTRICTED_FILE_UPLOAD_IF_NOT_HTML_FILE_EXTENSION")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_3,
            descriptionLabel = "URL_CONTAINING_JWT_TOKEN",
            htmlTemplate = "LEVEL_1/FileUpload",
            parameterName = "",
            sampleValues = "",
            requestMethod = RequestMethod.POST)
    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel3(
            @RequestParam("file") MultipartFile file)
            throws ServiceApplicationException, IOException {
        if (!ENDS_WITH_HTML_PATTERN.matcher(file.getOriginalFilename()).matches()) {
            String fileName = RANDOM.nextInt() + "_" + file.getOriginalFilename();
            Files.copy(
                    file.getInputStream(),
                    root.resolve(fileName),
                    StandardCopyOption.REPLACE_EXISTING);
            return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(
                    new GenericVulnerabilityResponseBean<String>(
                            STATIC_FILE_LOCATION + FrameworkConstants.SLASH + fileName, true),
                    HttpStatus.OK);
        } else {
            return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(
                    new GenericVulnerabilityResponseBean<String>("Input is invalid", false),
                    HttpStatus.OK);
        }
    }

    @AttackVector(
            vulnerabilityExposed = {
                VulnerabilitySubType.UNRESTRICTED_FILE_UPLOAD,
                VulnerabilitySubType.PERSISTENT_XSS,
                VulnerabilitySubType.REFLECTED_XSS
            },
            description = "UNRESTRICTED_FILE_UPLOAD_IF_NOT_HTML_NOT_HTM_FILE_EXTENSION")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_4,
            descriptionLabel = "URL_CONTAINING_JWT_TOKEN",
            htmlTemplate = "LEVEL_1/FileUpload",
            parameterName = "",
            sampleValues = "",
            requestMethod = RequestMethod.POST)
    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel4(
            @RequestParam("file") MultipartFile file)
            throws ServiceApplicationException, IOException {
        if (!ENDS_WITH_HTML_OR_HTM_PATTERN.matcher(file.getOriginalFilename()).matches()) {
            String fileName = RANDOM.nextInt() + "_" + file.getOriginalFilename();
            Files.copy(
                    file.getInputStream(),
                    root.resolve(fileName),
                    StandardCopyOption.REPLACE_EXISTING);
            return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(
                    new GenericVulnerabilityResponseBean<String>(
                            STATIC_FILE_LOCATION + FrameworkConstants.SLASH + fileName, true),
                    HttpStatus.OK);
        } else {
            return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(
                    new GenericVulnerabilityResponseBean<String>("Input is invalid", false),
                    HttpStatus.OK);
        }
    }

    @AttackVector(
            vulnerabilityExposed = {
                VulnerabilitySubType.UNRESTRICTED_FILE_UPLOAD,
                VulnerabilitySubType.PERSISTENT_XSS,
                VulnerabilitySubType.REFLECTED_XSS
            },
            description =
                    "UNRESTRICTED_FILE_UPLOAD_IF_NOT_HTML_NOT_HTM_FILE_EXTENSION_CASE_INSENSITIVE")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_5,
            descriptionLabel = "URL_CONTAINING_JWT_TOKEN",
            htmlTemplate = "LEVEL_1/FileUpload",
            parameterName = "",
            sampleValues = "",
            requestMethod = RequestMethod.POST)
    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel5(
            @RequestParam("file") MultipartFile file)
            throws ServiceApplicationException, IOException {
        if (!ENDS_WITH_HTML_OR_HTM_PATTERN
                .matcher(file.getOriginalFilename().toLowerCase())
                .matches()) {
            String fileName = RANDOM.nextInt() + "_" + file.getOriginalFilename();
            Files.copy(
                    file.getInputStream(),
                    root.resolve(fileName),
                    StandardCopyOption.REPLACE_EXISTING);
            return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(
                    new GenericVulnerabilityResponseBean<String>(
                            STATIC_FILE_LOCATION + FrameworkConstants.SLASH + fileName, true),
                    HttpStatus.OK);
        } else {
            return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(
                    new GenericVulnerabilityResponseBean<String>("Input is invalid", false),
                    HttpStatus.OK);
        }
    }

    // WhiteList approach
    @AttackVector(
            vulnerabilityExposed = {
                VulnerabilitySubType.UNRESTRICTED_FILE_UPLOAD,
                VulnerabilitySubType.PERSISTENT_XSS,
                VulnerabilitySubType.REFLECTED_XSS
            },
            description =
                    "UNRESTRICTED_FILE_UPLOAD_IF_FILE_NAME_NOT_CONTAINS_.PNG_OR_.JPEG_CASE_INSENSITIVE")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_6,
            descriptionLabel = "URL_CONTAINING_JWT_TOKEN",
            htmlTemplate = "LEVEL_1/FileUpload",
            parameterName = "",
            sampleValues = "",
            requestMethod = RequestMethod.POST)
    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel6(
            @RequestParam("file") MultipartFile file)
            throws ServiceApplicationException, IOException {
        if (CONTAINS_PNG_OR_JPEG_PATTERN.matcher(file.getOriginalFilename()).matches()) {
            String fileName = RANDOM.nextInt() + "_" + file.getOriginalFilename();
            Files.copy(
                    file.getInputStream(),
                    root.resolve(fileName),
                    StandardCopyOption.REPLACE_EXISTING);
            return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(
                    new GenericVulnerabilityResponseBean<String>(
                            STATIC_FILE_LOCATION + FrameworkConstants.SLASH + fileName, true),
                    HttpStatus.OK);
        } else {
            return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(
                    new GenericVulnerabilityResponseBean<String>("Input is invalid", false),
                    HttpStatus.OK);
        }
    }

    // Null Byte
    @AttackVector(
            vulnerabilityExposed = {
                VulnerabilitySubType.UNRESTRICTED_FILE_UPLOAD,
                VulnerabilitySubType.NULL_BYTE,
                VulnerabilitySubType.PERSISTENT_XSS,
                VulnerabilitySubType.REFLECTED_XSS
            },
            description =
                    "UNRESTRICTED_FILE_UPLOAD_IF_FILE_NAME_NOT_ENDS_WITH_.PNG_OR_.JPEG_CASE_INSENSITIVE_AND_FILE_NAMES_CONSIDERED_BEFORE_NULL_BYTE")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_7,
            descriptionLabel = "URL_CONTAINING_JWT_TOKEN",
            htmlTemplate = "LEVEL_1/FileUpload",
            parameterName = "",
            sampleValues = "",
            requestMethod = RequestMethod.POST)
    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel7(
            @RequestParam("file") MultipartFile file)
            throws ServiceApplicationException, IOException {
        String fileName = file.getOriginalFilename();
        if (ENDS_WITH_PNG_OR_JPEG_PATTERN.matcher(fileName).matches()) {
            // This replicates the Null Byte Injection where higher level language validator worked
            // fine but the file api's it uses are vulnerable
            // to Null byte.
            if (fileName.contains(Constants.NULL_BYTE_CHARACTER)) {
                fileName = fileName.substring(0, fileName.indexOf(Constants.NULL_BYTE_CHARACTER));
            }
            fileName = RANDOM.nextInt() + "_" + file.getOriginalFilename();
            Files.copy(
                    file.getInputStream(),
                    root.resolve(fileName),
                    StandardCopyOption.REPLACE_EXISTING);
            return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(
                    new GenericVulnerabilityResponseBean<String>(
                            STATIC_FILE_LOCATION + FrameworkConstants.SLASH + fileName, true),
                    HttpStatus.OK);
        } else {
            return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(
                    new GenericVulnerabilityResponseBean<String>("Input is invalid", false),
                    HttpStatus.OK);
        }
    }

    //Vulnerable to file content (Magic number attack)
    @AttackVector(
            vulnerabilityExposed = {
                VulnerabilitySubType.UNRESTRICTED_FILE_UPLOAD,
                VulnerabilitySubType.PERSISTENT_XSS
            },
            description =
                    "UNRESTRICTED_FILE_UPLOAD_IF_FILE_NAME_NOT_ENDS_WITH_.PNG_OR_.JPEG_CASE_INSENSITIVE")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_8,
            descriptionLabel = "URL_CONTAINING_JWT_TOKEN",
            htmlTemplate = "LEVEL_1/FileUpload",
            parameterName = "",
            sampleValues = "",
            requestMethod = RequestMethod.POST)
    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel8(
            @RequestParam("file") MultipartFile file)
            throws ServiceApplicationException, IOException {
        String fileName = file.getOriginalFilename();
        if (ENDS_WITH_PNG_OR_JPEG_PATTERN.matcher(fileName).matches()) {
            fileName = RANDOM.nextInt() + "_" + file.getOriginalFilename();
            Files.copy(
                    file.getInputStream(),
                    root.resolve(fileName),
                    StandardCopyOption.REPLACE_EXISTING);
            return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(
                    new GenericVulnerabilityResponseBean<String>(
                            StringEscapeUtils.escapeHtml4(
                                    STATIC_FILE_LOCATION + FrameworkConstants.SLASH + fileName),
                            true),
                    HttpStatus.OK);
        } else {
            return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(
                    new GenericVulnerabilityResponseBean<String>("Input is invalid", false),
                    HttpStatus.OK);
        }
    }
}
