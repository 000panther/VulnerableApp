package org.sasanlabs.service.vulnerability.fileupload;

import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.Date;
import java.util.Random;

import org.sasanlabs.internal.utility.FrameworkConstants;
import org.sasanlabs.internal.utility.LevelConstants;
import org.sasanlabs.internal.utility.annotations.AttackVector;
import org.sasanlabs.internal.utility.annotations.VulnerableAppRequestMapping;
import org.sasanlabs.internal.utility.annotations.VulnerableAppRestController;
import org.sasanlabs.service.exception.ServiceApplicationException;
import org.sasanlabs.service.vulnerability.bean.GenericVulnerabilityResponseBean;
import org.sasanlabs.vulnerability.types.VulnerabilitySubType;
import org.sasanlabs.vulnerability.types.VulnerabilityType;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.multipart.MultipartFile;

/**
 * @author KSASAN preetkaran20@gmail.com Special Thanks
 *     <p>https://bezkoder.com/spring-boot-file-upload/
 *     <p>https://developer.mozilla.org/en-US/docs/Web/API/FormData/Using_FormData_Objects
 *     <p>https://www.youtube.com/watch?v=CmF9sEyKZNo
 */
@VulnerableAppRestController(
        descriptionLabel = "UNRESTRICTED_FILE_UPLOAD_VULNERABILITY",
        value = "UnrestrictedFileUpload",
        type = {VulnerabilityType.UNRESTRICTED_FILE_UPLOAD})
public class UnrestrictedFileUpload {
    private final Path root;

    private static final String STATIC_FILE_LOCATION = "upload";
    private static final String BASE_PATH = "static";
    private static final Random RANDOM = new Random(new Date().getTime());

    public UnrestrictedFileUpload() throws IOException, URISyntaxException {
        URI uploadDirectoryURI =
                new URI(
                        Thread.currentThread()
                                        .getContextClassLoader()
                                        .getResource(BASE_PATH)
                                        .toURI()
                                + FrameworkConstants.SLASH
                                + STATIC_FILE_LOCATION);
        root = Paths.get(uploadDirectoryURI);
        if (!root.toFile().exists()) {
            Files.createDirectory(Paths.get(uploadDirectoryURI));
        }
    }

    /**
     * Vuln included are: 1. Blacklisting some of the extensions 2. Case insensitive 3. Doesn't ends
     * with Extension 4. Null Byte 5. Directory Traversal 6. Not checking file content 7. XSS by
     * file names
     *
     * <p>8. try other ways possible
     *
     * @throws URISyntaxException
     */
    //Has XSS <img src="" onerror=alert(1) /> file name reflected and stored is there.
    //this has both File Upload and Xss as per my handling.
    @AttackVector(
            vulnerabilityExposed = VulnerabilitySubType.REFLECTED_XSS,
            description = "JWT_URL_EXPOSING_SECURE_INFORMATION")
    @AttackVector(
            vulnerabilityExposed = VulnerabilitySubType.PERSISTENT_XSS,
            description = "JWT_URL_EXPOSING_SECURE_INFORMATION")
    @AttackVector(
            vulnerabilityExposed = VulnerabilitySubType.PATH_TRAVERSAL,
            description = "JWT_URL_EXPOSING_SECURE_INFORMATION")
    @AttackVector(
            vulnerabilityExposed = VulnerabilitySubType.UNRESTRICTED_FILE_UPLOAD,
            description = "JWT_URL_EXPOSING_SECURE_INFORMATION")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_1,
            descriptionLabel = "URL_CONTAINING_JWT_TOKEN",
            htmlTemplate = "LEVEL_1/FileUpload",
            parameterName = "",
            sampleValues = "",
            requestMethod = RequestMethod.POST)
    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel1(
            @RequestParam("file") MultipartFile file)
            throws ServiceApplicationException, IOException, URISyntaxException {
        String fileName = file.getOriginalFilename();
        Files.copy(file.getInputStream(), root.resolve(fileName), StandardCopyOption.REPLACE_EXISTING);
        return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(
                new GenericVulnerabilityResponseBean<String>(STATIC_FILE_LOCATION + FrameworkConstants.SLASH + fileName, true), HttpStatus.OK);
    }

    //Has XSS <img src="" onerror=alert(1) /> file name reflected and stored is there.
    @AttackVector(
            vulnerabilityExposed = VulnerabilitySubType.REFLECTED_XSS,
            description = "JWT_URL_EXPOSING_SECURE_INFORMATION")
    @AttackVector(
            vulnerabilityExposed = VulnerabilitySubType.PERSISTENT_XSS,
            description = "JWT_URL_EXPOSING_SECURE_INFORMATION")
    @AttackVector(
            vulnerabilityExposed = VulnerabilitySubType.UNRESTRICTED_FILE_UPLOAD,
            description = "JWT_URL_EXPOSING_SECURE_INFORMATION")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_2,
            descriptionLabel = "URL_CONTAINING_JWT_TOKEN",
            htmlTemplate = "LEVEL_1/FileUpload",
            parameterName = "",
            sampleValues = "",
            requestMethod = RequestMethod.POST)
    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel2(
            @RequestParam("file") MultipartFile file)
            throws ServiceApplicationException, IOException {
        String fileName = RANDOM.nextInt() + "_" + file.getOriginalFilename();
        Files.copy(file.getInputStream(), root.resolve(fileName), StandardCopyOption.REPLACE_EXISTING);
        return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(
                new GenericVulnerabilityResponseBean<String>(STATIC_FILE_LOCATION + FrameworkConstants.SLASH + fileName, true), HttpStatus.OK);

    }
    
    @AttackVector(
            vulnerabilityExposed = VulnerabilitySubType.REFLECTED_XSS,
            description = "JWT_URL_EXPOSING_SECURE_INFORMATION")
    @AttackVector(
            vulnerabilityExposed = VulnerabilitySubType.PERSISTENT_XSS,
            description = "JWT_URL_EXPOSING_SECURE_INFORMATION")
    @AttackVector(
            vulnerabilityExposed = VulnerabilitySubType.UNRESTRICTED_FILE_UPLOAD,
            description = "JWT_URL_EXPOSING_SECURE_INFORMATION")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_3,
            descriptionLabel = "URL_CONTAINING_JWT_TOKEN",
            htmlTemplate = "LEVEL_1/FileUpload",
            parameterName = "",
            sampleValues = "",
            requestMethod = RequestMethod.POST)
    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel3(
            @RequestParam("file") MultipartFile file)
            throws ServiceApplicationException, IOException {
	    	if(!file.getOriginalFilename().endsWith(".js") || file.getOriginalFilename().endsWith(".html")) {
	        String fileName = RANDOM.nextInt() + "_" + file.getOriginalFilename();
	        Files.copy(file.getInputStream(), root.resolve(fileName), StandardCopyOption.REPLACE_EXISTING);
	        return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(
	                new GenericVulnerabilityResponseBean<String>(STATIC_FILE_LOCATION + FrameworkConstants.SLASH + fileName, true), HttpStatus.OK);
	    } else {
	        return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(
	                new GenericVulnerabilityResponseBean<String>("Input is invalid", false), HttpStatus.OK);
	    }
    }
}
