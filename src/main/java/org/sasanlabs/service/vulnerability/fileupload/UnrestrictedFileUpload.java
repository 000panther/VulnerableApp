package org.sasanlabs.service.vulnerability.fileupload;

import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.Date;
import java.util.Random;
import org.sasanlabs.internal.utility.FrameworkConstants;
import org.sasanlabs.internal.utility.LevelConstants;
import org.sasanlabs.internal.utility.annotations.AttackVector;
import org.sasanlabs.internal.utility.annotations.VulnerableAppRequestMapping;
import org.sasanlabs.internal.utility.annotations.VulnerableAppRestController;
import org.sasanlabs.service.exception.ServiceApplicationException;
import org.sasanlabs.service.vulnerability.bean.GenericVulnerabilityResponseBean;
import org.sasanlabs.vulnerability.types.VulnerabilitySubType;
import org.sasanlabs.vulnerability.types.VulnerabilityType;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.multipart.MultipartFile;

/**
 * @author KSASAN preetkaran20@gmail.com Special Thanks
 *     <p>https://bezkoder.com/spring-boot-file-upload/
 *     <p>https://developer.mozilla.org/en-US/docs/Web/API/FormData/Using_FormData_Objects
 *     <p>https://www.youtube.com/watch?v=CmF9sEyKZNo
 */
@VulnerableAppRestController(
        descriptionLabel = "UNRESTRICTED_FILE_UPLOAD_VULNERABILITY",
        value = "UnrestrictedFileUpload",
        type = {VulnerabilityType.UNRESTRICTED_FILE_UPLOAD})
public class UnrestrictedFileUpload {
    private final Path root;

    private static final String STATIC_FILE_LOCATION = "upload";
    private static final String BASE_PATH = "static";
    private static final Random RANDOM = new Random(new Date().getTime());

    public UnrestrictedFileUpload() throws IOException, URISyntaxException {
        URI uploadDirectoryURI =
                new URI(
                        Thread.currentThread()
                                        .getContextClassLoader()
                                        .getResource(BASE_PATH)
                                        .toURI()
                                + FrameworkConstants.SLASH
                                + STATIC_FILE_LOCATION);
        root = Paths.get(uploadDirectoryURI);
        if (!root.toFile().exists()) {
            Files.createDirectory(root);
        }
    }

    /**
     * Vuln included are: 1. Blacklisting some of the extensions 2. Case insensitive 3. Doesn't ends
     * with Extension 4. Null Byte 5. Directory Traversal 6. Not checking file content 7. XSS by
     * file names
     *
     * <p>8. try other ways possible
     *
     * @throws URISyntaxException
     */
    // Has XSS <img src="" onerror=alert(1) /> file name reflected and stored is there.
    // this has both File Upload and Xss as per my handling.
    @AttackVector(
            vulnerabilityExposed = VulnerabilitySubType.REFLECTED_XSS,
            description = "UNRESTRICTED_FILE_UPLOAD_REFLECTED_XSS_FILE_NAME")
    @AttackVector(
            vulnerabilityExposed = VulnerabilitySubType.PERSISTENT_XSS,
            description = "UNRESTRICTED_FILE_UPLOAD_PERSISTENT_XSS_FILE_CONTENT")
    @AttackVector(
            vulnerabilityExposed = VulnerabilitySubType.PATH_TRAVERSAL,
            description = "UNRESTRICTED_FILE_UPLOAD_PATH_TRAVERSAL_FILE_NAME")
    @AttackVector(
            vulnerabilityExposed = VulnerabilitySubType.UNRESTRICTED_FILE_UPLOAD,
            description = "UNRESTRICTED_FILE_UPLOAD_NO_VALIDATION_FILE_NAME")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_1,
            descriptionLabel = "URL_CONTAINING_JWT_TOKEN",
            htmlTemplate = "LEVEL_1/FileUpload",
            parameterName = "",
            sampleValues = "",
            requestMethod = RequestMethod.POST)
    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel1(
            @RequestParam("file") MultipartFile file)
            throws ServiceApplicationException, IOException, URISyntaxException {
        String fileName = file.getOriginalFilename();
        Files.copy(
                file.getInputStream(), root.resolve(fileName), StandardCopyOption.REPLACE_EXISTING);
        return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(
                new GenericVulnerabilityResponseBean<String>(
                        STATIC_FILE_LOCATION + FrameworkConstants.SLASH + fileName, true),
                HttpStatus.OK);
    }

    // Has XSS <img src="" onerror=alert(1) /> file name reflected and stored is there.
    @AttackVector(
            vulnerabilityExposed = VulnerabilitySubType.REFLECTED_XSS,
            description = "UNRESTRICTED_FILE_UPLOAD_REFLECTED_XSS_FILE_NAME")
    @AttackVector(
            vulnerabilityExposed = VulnerabilitySubType.PERSISTENT_XSS,
            description = "UNRESTRICTED_FILE_UPLOAD_PERSISTENT_XSS_FILE_CONTENT")
    @AttackVector(
            vulnerabilityExposed = VulnerabilitySubType.UNRESTRICTED_FILE_UPLOAD,
            description = "UNRESTRICTED_FILE_UPLOAD_NO_VALIDATION_FILE_NAME")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_2,
            descriptionLabel = "URL_CONTAINING_JWT_TOKEN",
            htmlTemplate = "LEVEL_1/FileUpload",
            parameterName = "",
            sampleValues = "",
            requestMethod = RequestMethod.POST)
    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel2(
            @RequestParam("file") MultipartFile file)
            throws ServiceApplicationException, IOException {
        String fileName = RANDOM.nextInt() + "_" + file.getOriginalFilename();
        Files.copy(
                file.getInputStream(), root.resolve(fileName), StandardCopyOption.REPLACE_EXISTING);
        return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(
                new GenericVulnerabilityResponseBean<String>(
                        STATIC_FILE_LOCATION + FrameworkConstants.SLASH + fileName, true),
                HttpStatus.OK);
    }

    // a .htm extension breaks the file upload vulnerability
    @AttackVector(
            vulnerabilityExposed = VulnerabilitySubType.REFLECTED_XSS,
            description = "UNRESTRICTED_FILE_UPLOAD_REFLECTED_XSS_FILE_NAME")
    @AttackVector(
            vulnerabilityExposed = VulnerabilitySubType.PERSISTENT_XSS,
            description = "UNRESTRICTED_FILE_UPLOAD_PERSISTENT_XSS_FILE_CONTENT")
    @AttackVector(
            vulnerabilityExposed = VulnerabilitySubType.UNRESTRICTED_FILE_UPLOAD,
            description = "UNRESTRICTED_FILE_UPLOAD_IF_NOT_HTML_FILE_EXTENSION")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_3,
            descriptionLabel = "URL_CONTAINING_JWT_TOKEN",
            htmlTemplate = "LEVEL_1/FileUpload",
            parameterName = "",
            sampleValues = "",
            requestMethod = RequestMethod.POST)
    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel3(
            @RequestParam("file") MultipartFile file)
            throws ServiceApplicationException, IOException {
        if (!file.getOriginalFilename().endsWith(".html")) {
            String fileName = RANDOM.nextInt() + "_" + file.getOriginalFilename();
            Files.copy(
                    file.getInputStream(),
                    root.resolve(fileName),
                    StandardCopyOption.REPLACE_EXISTING);
            return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(
                    new GenericVulnerabilityResponseBean<String>(
                            STATIC_FILE_LOCATION + FrameworkConstants.SLASH + fileName, true),
                    HttpStatus.OK);
        } else {
            return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(
                    new GenericVulnerabilityResponseBean<String>("Input is invalid", false),
                    HttpStatus.OK);
        }
    }

    @AttackVector(
            vulnerabilityExposed = VulnerabilitySubType.REFLECTED_XSS,
            description = "UNRESTRICTED_FILE_UPLOAD_REFLECTED_XSS_FILE_NAME")
    @AttackVector(
            vulnerabilityExposed = VulnerabilitySubType.PERSISTENT_XSS,
            description = "UNRESTRICTED_FILE_UPLOAD_PERSISTENT_XSS_FILE_CONTENT")
    @AttackVector(
            vulnerabilityExposed = VulnerabilitySubType.UNRESTRICTED_FILE_UPLOAD,
            description = "UNRESTRICTED_FILE_UPLOAD_IF_NOT_HTML_NOT_HTM_FILE_EXTENSION")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_4,
            descriptionLabel = "URL_CONTAINING_JWT_TOKEN",
            htmlTemplate = "LEVEL_1/FileUpload",
            parameterName = "",
            sampleValues = "",
            requestMethod = RequestMethod.POST)
    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel4(
            @RequestParam("file") MultipartFile file)
            throws ServiceApplicationException, IOException {
        if (!file.getOriginalFilename().endsWith(".html")
                && !file.getOriginalFilename().endsWith(".htm")) {
            String fileName = RANDOM.nextInt() + "_" + file.getOriginalFilename();
            Files.copy(
                    file.getInputStream(),
                    root.resolve(fileName),
                    StandardCopyOption.REPLACE_EXISTING);
            return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(
                    new GenericVulnerabilityResponseBean<String>(
                            STATIC_FILE_LOCATION + FrameworkConstants.SLASH + fileName, true),
                    HttpStatus.OK);
        } else {
            return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(
                    new GenericVulnerabilityResponseBean<String>("Input is invalid", false),
                    HttpStatus.OK);
        }
    }

    @AttackVector(
            vulnerabilityExposed = VulnerabilitySubType.REFLECTED_XSS,
            description = "UNRESTRICTED_FILE_UPLOAD_REFLECTED_XSS_FILE_NAME")
    @AttackVector(
            vulnerabilityExposed = VulnerabilitySubType.PERSISTENT_XSS,
            description = "UNRESTRICTED_FILE_UPLOAD_PERSISTENT_XSS_FILE_CONTENT")
    @AttackVector(
            vulnerabilityExposed = VulnerabilitySubType.UNRESTRICTED_FILE_UPLOAD,
            description =
                    "UNRESTRICTED_FILE_UPLOAD_IF_NOT_HTML_NOT_HTM_FILE_EXTENSION_CASE_INSENSITIVE")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_5,
            descriptionLabel = "URL_CONTAINING_JWT_TOKEN",
            htmlTemplate = "LEVEL_1/FileUpload",
            parameterName = "",
            sampleValues = "",
            requestMethod = RequestMethod.POST)
    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel5(
            @RequestParam("file") MultipartFile file)
            throws ServiceApplicationException, IOException {
        if (!file.getOriginalFilename().toLowerCase().endsWith(".html")
                && !file.getOriginalFilename().toLowerCase().endsWith(".htm")) {
            String fileName = RANDOM.nextInt() + "_" + file.getOriginalFilename();
            Files.copy(
                    file.getInputStream(),
                    root.resolve(fileName),
                    StandardCopyOption.REPLACE_EXISTING);
            return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(
                    new GenericVulnerabilityResponseBean<String>(
                            STATIC_FILE_LOCATION + FrameworkConstants.SLASH + fileName, true),
                    HttpStatus.OK);
        } else {
            return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(
                    new GenericVulnerabilityResponseBean<String>("Input is invalid", false),
                    HttpStatus.OK);
        }
    }

    // WhiteList approach
    @AttackVector(
            vulnerabilityExposed = VulnerabilitySubType.REFLECTED_XSS,
            description = "UNRESTRICTED_FILE_UPLOAD_REFLECTED_XSS_FILE_NAME")
    @AttackVector(
            vulnerabilityExposed = VulnerabilitySubType.PERSISTENT_XSS,
            description = "UNRESTRICTED_FILE_UPLOAD_PERSISTENT_XSS_FILE_CONTENT")
    @AttackVector(
            vulnerabilityExposed = VulnerabilitySubType.UNRESTRICTED_FILE_UPLOAD,
            description =
                    "UNRESTRICTED_FILE_UPLOAD_IF_NOT_HTML_NOT_HTM_FILE_EXTENSION_CASE_INSENSITIVE")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_6,
            descriptionLabel = "URL_CONTAINING_JWT_TOKEN",
            htmlTemplate = "LEVEL_1/FileUpload",
            parameterName = "",
            sampleValues = "",
            requestMethod = RequestMethod.POST)
    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel6(
            @RequestParam("file") MultipartFile file)
            throws ServiceApplicationException, IOException {
        if (file.getOriginalFilename().toLowerCase().endsWith(".png")
                || file.getOriginalFilename().toLowerCase().endsWith(".jpeg")) {
            String fileName = RANDOM.nextInt() + "_" + file.getOriginalFilename();
            Files.copy(
                    file.getInputStream(),
                    root.resolve(fileName),
                    StandardCopyOption.REPLACE_EXISTING);
            return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(
                    new GenericVulnerabilityResponseBean<String>(
                            STATIC_FILE_LOCATION + FrameworkConstants.SLASH + fileName, true),
                    HttpStatus.OK);
        } else {
            return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(
                    new GenericVulnerabilityResponseBean<String>("Input is invalid", false),
                    HttpStatus.OK);
        }
    }

    // Null Byte
    @AttackVector(
            vulnerabilityExposed = VulnerabilitySubType.REFLECTED_XSS,
            description = "UNRESTRICTED_FILE_UPLOAD_REFLECTED_XSS_FILE_NAME")
    @AttackVector(
            vulnerabilityExposed = VulnerabilitySubType.PERSISTENT_XSS,
            description = "UNRESTRICTED_FILE_UPLOAD_PERSISTENT_XSS_FILE_CONTENT")
    @AttackVector(
            vulnerabilityExposed = VulnerabilitySubType.UNRESTRICTED_FILE_UPLOAD,
            description =
                    "UNRESTRICTED_FILE_UPLOAD_IF_NOT_HTML_NOT_HTM_FILE_EXTENSION_CASE_INSENSITIVE")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_7,
            descriptionLabel = "URL_CONTAINING_JWT_TOKEN",
            htmlTemplate = "LEVEL_1/FileUpload",
            parameterName = "",
            sampleValues = "",
            requestMethod = RequestMethod.POST)
    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel7(
            @RequestParam("file") MultipartFile file)
            throws ServiceApplicationException, IOException {
        if (file.getOriginalFilename().toLowerCase().endsWith(".png")
                || file.getOriginalFilename().toLowerCase().endsWith(".jpeg")) {
            String fileName = RANDOM.nextInt() + "_" + file.getOriginalFilename();
            Files.copy(
                    file.getInputStream(),
                    root.resolve(fileName),
                    StandardCopyOption.REPLACE_EXISTING);
            return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(
                    new GenericVulnerabilityResponseBean<String>(
                            STATIC_FILE_LOCATION + FrameworkConstants.SLASH + fileName, true),
                    HttpStatus.OK);
        } else {
            return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(
                    new GenericVulnerabilityResponseBean<String>("Input is invalid", false),
                    HttpStatus.OK);
        }
    }
}
